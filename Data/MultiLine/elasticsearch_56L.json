{"conflicts":[
  {
    "devdecision": "Combination",
    "id": 74440,
    "v2": "",
    "resolution": "abstract Factory getParseFromSourceFactory();  abstract Factory getObjectSubfieldFactory(Function<SearchLookup, ObjectFieldScript.LeafFactory> parentScriptFactory);",
    "conflict": "abstract Factory getParseFromSourceFactory();  abstract Factory getObjectSubfieldFactory(Function<SearchLookup, ObjectFieldScript.LeafFactory> parentScriptFactory);  abstract RuntimeField newRuntimeField(Factory scriptFactory);"
  },
  {
    "devdecision": "Manual",
    "id": 74441,
    "v2": "return createRuntimeField(parseFromSourceFactory);",
    "resolution": "if (parentScriptFactory == null) { return createRuntimeField(getParseFromSourceFactory()); } return createRuntimeField(getObjectSubfieldFactory(parentScriptFactory));",
    "conflict": "if (parentScriptFactory == null) { return newRuntimeField(getParseFromSourceFactory()); } return newRuntimeField(getObjectSubfieldFactory(parentScriptFactory));"
  },
  {
    "devdecision": "Manual",
    "id": 74452,
    "v2": "public final void parse(String name, MappingParserContext parserContext, Map<String, Object> fieldNode) {",
    "resolution": "protected abstract RuntimeField createRuntimeField(MappingParserContext parserContext, Function<SearchLookup, ObjectFieldScript.LeafFactory> parentScriptFactory);  public final void parse(String name, MappingParserContext parserContext, Map<String, Object> fieldNode) {",
    "conflict": "protected abstract RuntimeField createRuntimeField(Mapper.TypeParser.ParserContext parserContext, Function<SearchLookup, ObjectFieldScript.LeafFactory> parentScriptFactory);  public final void parse(String name, Mapper.TypeParser.ParserContext parserContext, Map<String, Object> fieldNode) {"
  },
  {
    "devdecision": "Version 2",
    "id": 74470,
    "v2": "if (this.lookup == null) { this.lookup = new SearchLookup( getMapperService(), (fieldType, searchLookup) -> indexFieldDataService.apply(fieldType, fullyQualifiedIndex.getName(), searchLookup));",
    "resolution": "if (this.lookup == null) { this.lookup = new SearchLookup( getMapperService(), (fieldType, searchLookup) -> indexFieldDataService.apply(fieldType, fullyQualifiedIndex.getName(), searchLookup));",
    "conflict": "if (lookup == null) { lookup = new SearchLookup(getMapperService(), this::getForField);"
  },
  {
    "devdecision": "Manual",
    "id": 74491,
    "v2": "SnapshotsService.MAX_CONCURRENT_SNAPSHOT_OPERATIONS_SETTING, FsHealthService.ENABLED_SETTING, FsHealthService.REFRESH_INTERVAL_SETTING, FsHealthService.SLOW_PATH_LOGGING_THRESHOLD_SETTING, IndexingPressure.MAX_INDEXING_BYTES);",
    "resolution": "SnapshotsService.MAX_CONCURRENT_SNAPSHOT_OPERATIONS_SETTING, FsHealthService.ENABLED_SETTING, FsHealthService.REFRESH_INTERVAL_SETTING, FsHealthService.SLOW_PATH_LOGGING_THRESHOLD_SETTING, IndexingPressure.MAX_INDEXING_BYTES, HandshakingTransportAddressConnector.PROBE_HANDSHAKE_TIMEOUT_SETTING, ReindexHeaders.REINDEX_INCLUDED_HEADERS);",
    "conflict": "ReindexHeaders.REINDEX_INCLUDED_HEADERS);"
  },
  {
    "devdecision": "Version 1",
    "id": 74528,
    "v2": "assertEquals(\"reindex from [source1] to [dest]\", info.getDescription()); assertEquals(\"indices:data/write/reindex\", info.getAction());",
    "resolution": "// TODO: Name change assertEquals(\"persistent reindex\", info.getDescription()); assertEquals(\"reindex/job[c]\", info.getAction());",
    "conflict": "// TODO: Name change assertEquals(\"persistent reindex\", info.getDescription()); assertEquals(\"reindex/job[c]\", info.getAction());"
  },
  {
    "devdecision": "Combination",
    "id": 74531,
    "v2": "public static final String[] ALL_ARRAY = new String[] { NONE, ALL, MONITOR, MONITOR_TRANSFORM_DEPRECATED, MONITOR_TRANSFORM, MONITOR_ML, MONITOR_WATCHER, MONITOR_ROLLUP, MANAGE, MANAGE_TRANSFORM_DEPRECATED, MANAGE_TRANSFORM,",
    "resolution": "public static final String MANAGE_ENRICH = \"manage_enrich\"; public static final String[] ALL_ARRAY = new String[] { NONE, ALL, MONITOR, MONITOR_TRANSFORM_DEPRECATED, MONITOR_TRANSFORM, MONITOR_ML, MONITOR_WATCHER, MONITOR_ROLLUP, MANAGE, MANAGE_TRANSFORM_DEPRECATED, MANAGE_TRANSFORM,",
    "conflict": "public static final String MANAGE_ENRICH = \"manage_enrich\"; public static final String[] ALL_ARRAY = new String[] { NONE, ALL, MONITOR, MONITOR_DATA_FRAME_TRANSFORMS, MONITOR_ML, MONITOR_WATCHER, MONITOR_ROLLUP, MANAGE, MANAGE_DATA_FRAME_TRANSFORMS,"
  },
  {
    "devdecision": "Combination",
    "id": 74534,
    "v2": "public static final String[] ALL_ARRAY = new String[] { NONE, ALL, MONITOR, MONITOR_TRANSFORM_DEPRECATED, MONITOR_TRANSFORM, MONITOR_ML, MONITOR_WATCHER, MONITOR_ROLLUP, MANAGE, MANAGE_TRANSFORM_DEPRECATED, MANAGE_TRANSFORM,",
    "resolution": "public static final String MANAGE_ENRICH = \"manage_enrich\"; public static final String[] ALL_ARRAY = new String[] { NONE, ALL, MONITOR, MONITOR_TRANSFORM_DEPRECATED, MONITOR_TRANSFORM, MONITOR_ML, MONITOR_WATCHER, MONITOR_ROLLUP, MANAGE, MANAGE_TRANSFORM_DEPRECATED, MANAGE_TRANSFORM,",
    "conflict": "public static final String MANAGE_ENRICH = \"manage_enrich\"; public static final String[] ALL_ARRAY = new String[] { NONE, ALL, MONITOR, MONITOR_DATA_FRAME_TRANSFORMS, MONITOR_ML, MONITOR_WATCHER, MONITOR_ROLLUP, MANAGE, MANAGE_DATA_FRAME_TRANSFORMS,"
  },
  {
    "devdecision": "Concatenation",
    "id": 74573,
    "v2": "public static final NamedClusterPrivilege DELEGATE_PKI = new ActionClusterPrivilege(\"delegate_pki\", Sets.newHashSet(DelegatePkiAuthenticationAction.NAME, InvalidateTokenAction.NAME));  public static final NamedClusterPrivilege MANAGE_OWN_API_KEY = ManageOwnApiKeyClusterPrivilege.INSTANCE;",
    "resolution": "public static final NamedClusterPrivilege MANAGE_ENRICH = new ActionClusterPrivilege(\"manage_enrich\", MANAGE_ENRICH_AUTOMATON);public static final NamedClusterPrivilege DELEGATE_PKI = new ActionClusterPrivilege(\"delegate_pki\", Sets.newHashSet(DelegatePkiAuthenticationAction.NAME, InvalidateTokenAction.NAME));  public static final NamedClusterPrivilege MANAGE_OWN_API_KEY = ManageOwnApiKeyClusterPrivilege.INSTANCE;",
    "conflict": "public static final NamedClusterPrivilege MANAGE_ENRICH = new ActionClusterPrivilege(\"manage_enrich\", MANAGE_ENRICH_AUTOMATON);"
  },
  {
    "devdecision": "Concatenation",
    "id": 74578,
    "v2": "public static final NamedClusterPrivilege DELEGATE_PKI = new ActionClusterPrivilege(\"delegate_pki\", Set.of(DelegatePkiAuthenticationAction.NAME, InvalidateTokenAction.NAME));  public static final NamedClusterPrivilege MANAGE_OWN_API_KEY = ManageOwnApiKeyClusterPrivilege.INSTANCE;",
    "resolution": "public static final NamedClusterPrivilege MANAGE_ENRICH = new ActionClusterPrivilege(\"manage_enrich\", MANAGE_ENRICH_AUTOMATON);public static final NamedClusterPrivilege DELEGATE_PKI = new ActionClusterPrivilege(\"delegate_pki\", Set.of(DelegatePkiAuthenticationAction.NAME, InvalidateTokenAction.NAME));  public static final NamedClusterPrivilege MANAGE_OWN_API_KEY = ManageOwnApiKeyClusterPrivilege.INSTANCE;",
    "conflict": "public static final NamedClusterPrivilege MANAGE_ENRICH = new ActionClusterPrivilege(\"manage_enrich\", MANAGE_ENRICH_AUTOMATON);"
  },
  {
    "devdecision": "Concatenation",
    "id": 74586,
    "v2": "import org.elasticsearch.ingest.WrappingProcessor;",
    "resolution": "import org.elasticsearch.ingest.WrappingProcessor;import java.util.concurrent.CopyOnWriteArrayList; import java.util.function.BiConsumer;",
    "conflict": "import java.util.concurrent.CopyOnWriteArrayList; import java.util.function.BiConsumer;"
  },
  {
    "devdecision": "Concatenation",
    "id": 74593,
    "v2": "import org.elasticsearch.ingest.WrappingProcessor;",
    "resolution": "import org.elasticsearch.ingest.WrappingProcessor;import java.util.concurrent.CopyOnWriteArrayList; import java.util.function.BiConsumer;",
    "conflict": "import java.util.concurrent.CopyOnWriteArrayList; import java.util.function.BiConsumer;"
  },
  {
    "devdecision": "Version 2",
    "id": 74600,
    "v2": "",
    "resolution": "",
    "conflict": "import org.elasticsearch.action.ActionRequestValidationException; import org.elasticsearch.action.ActionRunnable; import org.elasticsearch.action.bulk.BackoffPolicy; import org.elasticsearch.action.bulk.BulkItemResponse.Failure; import org.elasticsearch.action.index.IndexRequest; import org.elasticsearch.action.search.SearchRequest;"
  },
  {
    "devdecision": "Version 1",
    "id": 74629,
    "v2": "public Releasable openConnection(DiscoveryNode node, ConnectionProfile profile, ActionListener<Connection> listener) { listener.onResponse(createConnection(node)); return () -> {}; }",
    "resolution": "",
    "conflict": ""
  },
  {
    "devdecision": "Manual",
    "id": 74640,
    "v2": "MultiBucketConsumerService.TooManyBucketsException::new, 149, Version.V_7_0_0);",
    "resolution": "MultiBucketConsumerService.TooManyBucketsException::new, 149, Version.V_7_0_0), COORDINATION_STATE_REJECTED_EXCEPTION(org.elasticsearch.cluster.coordination.CoordinationStateRejectedException.class, org.elasticsearch.cluster.coordination.CoordinationStateRejectedException::new, 150, Version.V_7_0_0);",
    "conflict": "MultiBucketConsumerService.TooManyBucketsException::new, 149, Version.V_7_0_0_alpha1), COORDINATION_STATE_REJECTED_EXCEPTION(org.elasticsearch.cluster.coordination.CoordinationStateRejectedException.class, org.elasticsearch.cluster.coordination.CoordinationStateRejectedException::new, 150, Version.V_7_0_0_alpha1);"
  },
  {
    "devdecision": "Version 1",
    "id": 74645,
    "v2": "ElectMasterService electMasterService = new ElectMasterService(SETTINGS); nodeRemovalExecutor = new ZenDiscovery.NodeRemovalClusterStateTaskExecutor(allocationService, electMasterService, s -> { throw new AssertionError(\"rejoin not implemented\"); }, logger); joinTaskExecutor = new NodeJoinController.JoinTaskExecutor(allocationService, electMasterService, logger);",
    "resolution": "nodeRemovalExecutor = new NodeRemovalClusterStateTaskExecutor(allocationService, logger); joinTaskExecutor = new JoinTaskExecutor(allocationService, logger);",
    "conflict": "nodeRemovalExecutor = new NodeRemovalClusterStateTaskExecutor(allocationService, logger); joinTaskExecutor = new JoinTaskExecutor(allocationService, logger);"
  },
  {
    "devdecision": "Version 1",
    "id": 74654,
    "v2": "import org.elasticsearch.transport.TransportRequestOptions; import org.elasticsearch.transport.TransportResponse; import org.elasticsearch.transport.TransportResponseHandler; import org.elasticsearch.transport.TransportService; import org.elasticsearch.transport.TransportStats;",
    "resolution": "",
    "conflict": ""
  },
  {
    "devdecision": "Concatenation",
    "id": 74670,
    "v2": "/** Setting for enabling or disabling Beats extensions. Defaults to true. */ public static final Setting<Boolean> BEATS_ENABLED = Setting.boolSetting(\"xpack.beats.enabled\", true,",
    "resolution": "/** * Setting for enabling or disabling the index lifecycle extension. Defaults to true. */ public static final Setting<Boolean> INDEX_LIFECYCLE_ENABLED = Setting.boolSetting(\"xpack.ilm.enabled\", true,/** Setting for enabling or disabling Beats extensions. Defaults to true. */ public static final Setting<Boolean> BEATS_ENABLED = Setting.boolSetting(\"xpack.beats.enabled\", true,",
    "conflict": "/** * Setting for enabling or disabling the index lifecycle extension. Defaults to true. */ public static final Setting<Boolean> INDEX_LIFECYCLE_ENABLED = Setting.boolSetting(\"xpack.ilm.enabled\", true,"
  },
  {
    "devdecision": "Version 2",
    "id": 74672,
    "v2": "if (t instanceof FailedToCommitClusterStateException || t instanceof NotMasterException) { logger.debug(() -> new ParameterizedMessage(\"master could not publish cluster state or \" + \"stepped down before publishing action [{}], scheduling a retry\", actionName), t);",
    "resolution": "if (t instanceof FailedToCommitClusterStateException || t instanceof NotMasterException) { logger.debug(() -> new ParameterizedMessage(\"master could not publish cluster state or \" + \"stepped down before publishing action [{}], scheduling a retry\", actionName), t);",
    "conflict": "if (t instanceof FailedToCommitClusterStateException || (t instanceof NotMasterException)) { logger.debug(() -> new ParameterizedMessage(\"master could not publish cluster state or stepped down before publishing action [{}], scheduling a retry\", actionName), t);"
  },
  {
    "devdecision": "Version 2",
    "id": 74677,
    "v2": "public Map<String, String> removeCustom(String type) { return this.customMetaData.remove(type);",
    "resolution": "public Map<String, String> removeCustom(String type) { return this.customMetaData.remove(type);",
    "conflict": "public Builder removeCustom(String type) { this.customMetaData.remove(type); return this;"
  },
  {
    "devdecision": "Version 2",
    "id": 74678,
    "v2": "public Map<String, String> removeCustom(String type) { return this.customMetaData.remove(type);",
    "resolution": "public Map<String, String> removeCustom(String type) { return this.customMetaData.remove(type);",
    "conflict": "public Builder removeCustom(String type) { this.customMetaData.remove(type); return this;"
  },
  {
    "devdecision": "Combination",
    "id": 74680,
    "v2": "",
    "resolution": "import static org.elasticsearch.client.indexlifecycle.LifecyclePolicyTests.createRandomPolicy;",
    "conflict": "import static org.elasticsearch.client.indexlifecycle.LifecyclePolicyTests.createRandomPolicy; import static org.elasticsearch.index.RandomCreateIndexGenerator.randomAliases; import static org.elasticsearch.index.RandomCreateIndexGenerator.randomCreateIndexRequest; import static org.elasticsearch.index.RandomCreateIndexGenerator.randomIndexSettings; import static org.elasticsearch.index.alias.RandomAliasActionsGenerator.randomAliasAction;"
  },
  {
    "devdecision": "Combination",
    "id": 74683,
    "v2": "",
    "resolution": "import org.elasticsearch.client.indexlifecycle.ExplainLifecycleRequest; import org.elasticsearch.client.indexlifecycle.SetIndexLifecyclePolicyRequest; import org.elasticsearch.client.indexlifecycle.StartILMRequest; import org.elasticsearch.client.indexlifecycle.StopILMRequest;",
    "conflict": "import org.elasticsearch.protocol.xpack.XPackInfoRequest; import org.elasticsearch.client.indexlifecycle.ExplainLifecycleRequest; import org.elasticsearch.client.indexlifecycle.SetIndexLifecyclePolicyRequest; import org.elasticsearch.client.indexlifecycle.StartILMRequest; import org.elasticsearch.client.indexlifecycle.StopILMRequest; import org.elasticsearch.protocol.xpack.migration.IndexUpgradeInfoRequest;"
  },
  {
    "devdecision": "Combination",
    "id": 74684,
    "v2": "",
    "resolution": "import static org.elasticsearch.client.indexlifecycle.LifecyclePolicyTests.createRandomPolicy;",
    "conflict": "import static org.elasticsearch.client.indexlifecycle.LifecyclePolicyTests.createRandomPolicy; import static org.elasticsearch.index.RandomCreateIndexGenerator.randomAliases; import static org.elasticsearch.index.RandomCreateIndexGenerator.randomCreateIndexRequest; import static org.elasticsearch.index.RandomCreateIndexGenerator.randomIndexSettings; import static org.elasticsearch.index.alias.RandomAliasActionsGenerator.randomAliasAction;"
  },
  {
    "devdecision": "Combination",
    "id": 74690,
    "v2": "if (minNodeVersion.onOrAfter(Version.V_7_0_0_alpha1)) { Version oldMajor = Version.V_6_4_0.minimumCompatibilityVersion(); expectThrows(IllegalStateException.class, () -> MembershipAction.ensureMajorVersionBarrier(oldMajor, minNodeVersion));",
    "resolution": "if (minNodeVersion.onOrAfter(Version.V_7_0_0_alpha1)) { Version oldMajor = Version.V_6_4_0.minimumCompatibilityVersion(); expectThrows(IllegalStateException.class, () -> JoinTaskExecutor.ensureMajorVersionBarrier(oldMajor, minNodeVersion));",
    "conflict": "if (minNodeVersion.onOrAfter(Version.V_6_0_0_alpha1)) { Version oldMajor = randomFrom(allVersions().stream().filter(v -> v.major < 6).collect(Collectors.toList())); expectThrows(IllegalStateException.class, () -> JoinTaskExecutor.ensureMajorVersionBarrier(oldMajor, minNodeVersion));"
  },
  {
    "devdecision": "Version 2",
    "id": 74730,
    "v2": "indexWriter.softUpdateDocuments(uid, docs, softDeletesField); } else { indexWriter.softUpdateDocument(uid, docs.get(0), softDeletesField);",
    "resolution": "indexWriter.softUpdateDocuments(uid, docs, softDeletesField); } else { indexWriter.softUpdateDocument(uid, docs.get(0), softDeletesField);",
    "conflict": "indexWriter.softUpdateDocuments(uid, docs, softDeleteField); } else { indexWriter.softUpdateDocument(uid, docs.get(0), softDeleteField);"
  },
  {
    "devdecision": "Version 2",
    "id": 74734,
    "v2": "iwc.setSoftDeletesField(Lucene.SOFT_DELETES_FIELD); mergePolicy = new RecoverySourcePruneMergePolicy(SourceFieldMapper.RECOVERY_SOURCE_NAME, softDeletesPolicy::getRetentionQuery, new SoftDeletesRetentionMergePolicy(Lucene.SOFT_DELETES_FIELD, softDeletesPolicy::getRetentionQuery, mergePolicy));",
    "resolution": "iwc.setSoftDeletesField(Lucene.SOFT_DELETES_FIELD); mergePolicy = new RecoverySourcePruneMergePolicy(SourceFieldMapper.RECOVERY_SOURCE_NAME, softDeletesPolicy::getRetentionQuery, new SoftDeletesRetentionMergePolicy(Lucene.SOFT_DELETES_FIELD, softDeletesPolicy::getRetentionQuery, mergePolicy));",
    "conflict": "iwc.setSoftDeletesField(Lucene.SOFT_DELETE_FIELD); mergePolicy = new RecoverySourcePruneMergePolicy(SourceFieldMapper.RECOVERY_SOURCE_NAME, softDeletesPolicy::getRetentionQuery, new SoftDeletesRetentionMergePolicy(Lucene.SOFT_DELETE_FIELD, softDeletesPolicy::getRetentionQuery, mergePolicy));"
  },
  {
    "devdecision": "Version 2",
    "id": 74749,
    "v2": "doc.add(Lucene.newSoftDeletesField()); } writer.softUpdateDocument(new Term(\"id\", id), doc, Lucene.newSoftDeletesField());",
    "resolution": "doc.add(Lucene.newSoftDeletesField()); } writer.softUpdateDocument(new Term(\"id\", id), doc, Lucene.newSoftDeletesField());",
    "conflict": "doc.add(Lucene.newSoftDeleteField()); } writer.softUpdateDocument(new Term(\"id\", id), doc, Lucene.newSoftDeleteField());"
  },
  {
    "devdecision": "Version 2",
    "id": 74763,
    "v2": "return newStartedShard(primary, Settings.EMPTY); }  protected IndexShard newStartedShard(final boolean primary, Settings settings) throws IOException { return newStartedShard(primary, settings, new InternalEngineFactory());",
    "resolution": "return newStartedShard(primary, Settings.EMPTY); }  protected IndexShard newStartedShard(final boolean primary, Settings settings) throws IOException { return newStartedShard(primary, settings, new InternalEngineFactory());",
    "conflict": "return newStartedShard(primary, Settings.EMPTY, new InternalEngineFactory());"
  },
  {
    "devdecision": "Version 2",
    "id": 74767,
    "v2": "try { IndexShardTestCase.assertConsistentHistoryBetweenTranslogAndLucene(indexShard); } catch (AlreadyClosedException ignored) { // shard is closed }",
    "resolution": "try { IndexShardTestCase.assertConsistentHistoryBetweenTranslogAndLucene(indexShard); } catch (AlreadyClosedException ignored) { // shard is closed }",
    "conflict": "IndexShardTestCase.assertConsistentHistoryBetweenTranslogAndLucene(indexShard);"
  },
  {
    "devdecision": "Version 2",
    "id": 74783,
    "v2": "indexWriter.softUpdateDocuments(uid, docs, softDeletesField); } else { indexWriter.softUpdateDocument(uid, docs.get(0), softDeletesField);",
    "resolution": "indexWriter.softUpdateDocuments(uid, docs, softDeletesField); } else { indexWriter.softUpdateDocument(uid, docs.get(0), softDeletesField);",
    "conflict": "indexWriter.softUpdateDocuments(uid, docs, softDeleteField); } else { indexWriter.softUpdateDocument(uid, docs.get(0), softDeleteField);"
  },
  {
    "devdecision": "Version 2",
    "id": 74786,
    "v2": "",
    "resolution": "",
    "conflict": "public static DeletionStrategy processButSkipLucene(boolean currentlyDeleted, long seqNoOfDeletion, long versionOfDeletion) { return new DeletionStrategy(false, false, currentlyDeleted, seqNoOfDeletion, versionOfDeletion, null); }"
  },
  {
    "devdecision": "Version 2",
    "id": 74788,
    "v2": "iwc.setSoftDeletesField(Lucene.SOFT_DELETES_FIELD); mergePolicy = new RecoverySourcePruneMergePolicy(SourceFieldMapper.RECOVERY_SOURCE_NAME, softDeletesPolicy::getRetentionQuery, new SoftDeletesRetentionMergePolicy(Lucene.SOFT_DELETES_FIELD, softDeletesPolicy::getRetentionQuery, mergePolicy));",
    "resolution": "iwc.setSoftDeletesField(Lucene.SOFT_DELETES_FIELD); mergePolicy = new RecoverySourcePruneMergePolicy(SourceFieldMapper.RECOVERY_SOURCE_NAME, softDeletesPolicy::getRetentionQuery, new SoftDeletesRetentionMergePolicy(Lucene.SOFT_DELETES_FIELD, softDeletesPolicy::getRetentionQuery, mergePolicy));",
    "conflict": "iwc.setSoftDeletesField(Lucene.SOFT_DELETE_FIELD); mergePolicy = new RecoverySourcePruneMergePolicy(SourceFieldMapper.RECOVERY_SOURCE_NAME, softDeletesPolicy::getRetentionQuery, new SoftDeletesRetentionMergePolicy(Lucene.SOFT_DELETE_FIELD, softDeletesPolicy::getRetentionQuery, mergePolicy));"
  },
  {
    "devdecision": "Version 2",
    "id": 74800,
    "v2": "doc.add(Lucene.newSoftDeletesField()); } writer.softUpdateDocument(new Term(\"id\", id), doc, Lucene.newSoftDeletesField());",
    "resolution": "doc.add(Lucene.newSoftDeletesField()); } writer.softUpdateDocument(new Term(\"id\", id), doc, Lucene.newSoftDeletesField());",
    "conflict": "doc.add(Lucene.newSoftDeleteField()); } writer.softUpdateDocument(new Term(\"id\", id), doc, Lucene.newSoftDeleteField());"
  },
  {
    "devdecision": "Version 2",
    "id": 74808,
    "v2": "try { IndexShardTestCase.assertConsistentHistoryBetweenTranslogAndLucene(indexShard); } catch (AlreadyClosedException ignored) { // shard is closed }",
    "resolution": "try { IndexShardTestCase.assertConsistentHistoryBetweenTranslogAndLucene(indexShard); } catch (AlreadyClosedException ignored) { // shard is closed }",
    "conflict": "IndexShardTestCase.assertConsistentHistoryBetweenTranslogAndLucene(indexShard);"
  },
  {
    "devdecision": "Manual",
    "id": 74824,
    "v2": "assertBusy(() -> { assertThat(replica.getLastSyncedGlobalCheckpoint(), equalTo(19L)); assertThat(replica.estimateTranslogOperationsFromMinSeq(0), equalTo(0)); });",
    "resolution": "assertBusy(() -> { assertThat(replica.getLastSyncedGlobalCheckpoint(), equalTo(19L)); assertThat(getTranslog(replica).totalOperations(), equalTo(0)); });",
    "conflict": "assertBusy(() -> assertThat(getTranslog(replica).totalOperations(), equalTo(0)));"
  },
  {
    "devdecision": "Manual",
    "id": 74827,
    "v2": "assertBusy(() -> { assertThat(replica.getLastSyncedGlobalCheckpoint(), equalTo(19L)); assertThat(replica.estimateTranslogOperationsFromMinSeq(0), equalTo(0)); });",
    "resolution": "assertBusy(() -> { assertThat(replica.getLastSyncedGlobalCheckpoint(), equalTo(19L)); assertThat(getTranslog(replica).totalOperations(), equalTo(0)); });",
    "conflict": "assertBusy(() -> assertThat(getTranslog(replica).totalOperations(), equalTo(0)));"
  },
  {
    "devdecision": "Concatenation",
    "id": 74829,
    "v2": "import org.elasticsearch.protocol.xpack.license.DeleteLicenseRequest;",
    "resolution": "import org.elasticsearch.protocol.xpack.indexlifecycle.ExplainLifecycleRequest; import org.elasticsearch.protocol.xpack.indexlifecycle.SetIndexLifecyclePolicyRequest; import org.elasticsearch.protocol.xpack.indexlifecycle.StartILMRequest; import org.elasticsearch.protocol.xpack.indexlifecycle.StopILMRequest;import org.elasticsearch.protocol.xpack.license.DeleteLicenseRequest;",
    "conflict": "import org.elasticsearch.protocol.xpack.indexlifecycle.ExplainLifecycleRequest; import org.elasticsearch.protocol.xpack.indexlifecycle.SetIndexLifecyclePolicyRequest; import org.elasticsearch.protocol.xpack.indexlifecycle.StartILMRequest; import org.elasticsearch.protocol.xpack.indexlifecycle.StopILMRequest;"
  },
  {
    "devdecision": "Concatenation",
    "id": 74831,
    "v2": "import org.elasticsearch.protocol.xpack.migration.IndexUpgradeInfoRequest;",
    "resolution": "import org.elasticsearch.protocol.xpack.migration.IndexUpgradeInfoRequest;import org.elasticsearch.protocol.xpack.indexlifecycle.ExplainLifecycleRequest; import org.elasticsearch.protocol.xpack.indexlifecycle.SetIndexLifecyclePolicyRequest; import org.elasticsearch.protocol.xpack.indexlifecycle.StartILMRequest; import org.elasticsearch.protocol.xpack.indexlifecycle.StopILMRequest;",
    "conflict": "import org.elasticsearch.protocol.xpack.indexlifecycle.ExplainLifecycleRequest; import org.elasticsearch.protocol.xpack.indexlifecycle.SetIndexLifecyclePolicyRequest; import org.elasticsearch.protocol.xpack.indexlifecycle.StartILMRequest; import org.elasticsearch.protocol.xpack.indexlifecycle.StopILMRequest;"
  },
  {
    "devdecision": "Version 2",
    "id": 74840,
    "v2": "assert opPrimaryTerm <= this.operationPrimaryTerm : \"op term [ \" + opPrimaryTerm + \" ] > shard term [\" + this.operationPrimaryTerm + \"]\"; assert versionType.validateVersionForWrites(version);",
    "resolution": "assert opPrimaryTerm <= this.operationPrimaryTerm : \"op term [ \" + opPrimaryTerm + \" ] > shard term [\" + this.operationPrimaryTerm + \"]\"; assert versionType.validateVersionForWrites(version);",
    "conflict": "assert opPrimaryTerm <= this.primaryTerm : \"op term [ \" + opPrimaryTerm + \" ] > shard term [\" + this.primaryTerm + \"]\"; assert versionType.validateVersionForWrites(version) : \"version [\" + version + \"], version type [\" + versionType + \"]\";"
  },
  {
    "devdecision": "Version 2",
    "id": 74841,
    "v2": "assert opPrimaryTerm <= this.operationPrimaryTerm : \"op term [ \" + opPrimaryTerm + \" ] > shard term [\" + this.operationPrimaryTerm + \"]\"; assert versionType.validateVersionForWrites(version);",
    "resolution": "assert opPrimaryTerm <= this.operationPrimaryTerm : \"op term [ \" + opPrimaryTerm + \" ] > shard term [\" + this.operationPrimaryTerm + \"]\"; assert versionType.validateVersionForWrites(version);",
    "conflict": "assert opPrimaryTerm <= this.primaryTerm : \"op term [ \" + opPrimaryTerm + \" ] > shard term [\" + this.primaryTerm + \"]\"; assert versionType.validateVersionForWrites(version) : \"version [\" + version + \"], version type [\" + versionType + \"]\";"
  },
  {
    "devdecision": "Concatenation",
    "id": 74874,
    "v2": "/** Setting for enabling or disabling Beats extensions. Defaults to true. */ public static final Setting<Boolean> BEATS_ENABLED = Setting.boolSetting(\"xpack.beats.enabled\", true,",
    "resolution": "/** * Setting for enabling or disabling the index lifecycle extension. Defaults to true. */ public static final Setting<Boolean> INDEX_LIFECYCLE_ENABLED = Setting.boolSetting(\"xpack.index_lifecycle.enabled\", true,/** Setting for enabling or disabling Beats extensions. Defaults to true. */ public static final Setting<Boolean> BEATS_ENABLED = Setting.boolSetting(\"xpack.beats.enabled\", true,",
    "conflict": "/** * Setting for enabling or disabling the index lifecycle extension. Defaults to true. */ public static final Setting<Boolean> INDEX_LIFECYCLE_ENABLED = Setting.boolSetting(\"xpack.index_lifecycle.enabled\", true,"
  },
  {
    "devdecision": "Version 2",
    "id": 74927,
    "v2": "// LUCENE-8273: ConditionalTokenFilter allows analysis chains to skip // particular token filters based on the attributes of the current token. .put(\"termexclusion\", Void.class)",
    "resolution": "// LUCENE-8273: ConditionalTokenFilter allows analysis chains to skip // particular token filters based on the attributes of the current token. .put(\"termexclusion\", Void.class)",
    "conflict": "// not exposed, only used internally to index shingles and speed up phrase queries .put(\"fixedshingle\", Void.class)"
  },
  {
    "devdecision": "Version 2",
    "id": 74928,
    "v2": "// LUCENE-8273: ConditionalTokenFilter allows analysis chains to skip // particular token filters based on the attributes of the current token. .put(\"termexclusion\", Void.class)",
    "resolution": "// LUCENE-8273: ConditionalTokenFilter allows analysis chains to skip // particular token filters based on the attributes of the current token. .put(\"termexclusion\", Void.class)",
    "conflict": "// not exposed, only used internally to index shingles and speed up phrase queries .put(\"fixedshingle\", Void.class)"
  },
  {
    "devdecision": "Combination",
    "id": 75043,
    "v2": "private ResolvedIndices resolveIndexNames(Authentication authentication, String action, TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices, Role permission) {",
    "resolution": "private ResolvedIndices resolveIndexNames(Authentication authentication, String action, Object indicesRequest, TransportRequest mainRequest,MetaData metaData, AuthorizedIndices authorizedIndices, Role permission) {",
    "conflict": "private ResolvedIndices resolveIndexNames(Authentication authentication, String action, Object indicesRequest, TransportRequest mainRequest, MetaData metaData, AuthorizedIndices authorizedIndices) {"
  },
  {
    "devdecision": "Manual",
    "id": 75046,
    "v2": "ElasticsearchSecurityException denial(Authentication authentication, String action, TransportRequest request, String[] roleNames) { auditTrail.accessDenied(authentication.getUser(), action, request, roleNames);",
    "resolution": "ElasticsearchSecurityException denial(Authentication authentication, String action, TransportRequest request, String[] roleNames, @Nullable Set<String> specificIndices) { auditTrail.accessDenied(authentication.getUser(), action, request, roleNames, specificIndices);",
    "conflict": "ElasticsearchSecurityException denial(Authentication authentication, String action, TransportRequest request, @Nullable Set<String> specificIndices) { auditTrail.accessDenied(authentication.getUser(), action, request, specificIndices);"
  },
  {
    "devdecision": "Manual",
    "id": 75059,
    "v2": "String role = randomAlphaOfLengthBetween(1, 6); auditTrail.accessGranted(user, \"_action\", message, new String[] { role }); String userInfo = (runAs ? \"principal=[running as], run_by_principal=[_username]\" : \"principal=[_username]\") + \", roles=[\" + role + \"]\";",
    "resolution": "String role = randomAlphaOfLengthBetween(1, 6); auditTrail.accessGranted(user, \"_action\", message, new String[] { role }, null); String userInfo = (runAs ? \"principal=[running as], run_by_principal=[_username]\" : \"principal=[_username]\") + \", roles=[\" + role + \"]\";",
    "conflict": "String userInfo = runAs ? \"principal=[running as], run_by_principal=[_username]\" : \"principal=[_username]\"; auditTrail.accessGranted(user, \"_action\", message, null);"
  },
  {
    "devdecision": "Manual",
    "id": 75063,
    "v2": "String role = randomAlphaOfLengthBetween(1, 6); auditTrail.accessGranted(user, \"internal:_action\", message, new String[] { role }); String userInfo = (runAs ? \"principal=[running as], run_by_principal=[_username]\" : \"principal=[_username]\") + \", roles=[\" + role + \"]\";",
    "resolution": "String role = randomAlphaOfLengthBetween(1, 6); auditTrail.accessGranted(user, \"internal:_action\", message, new String[] { role }, null); String userInfo = (runAs ? \"principal=[running as], run_by_principal=[_username]\" : \"principal=[_username]\") + \", roles=[\" + role + \"]\";",
    "conflict": "String userInfo = runAs ? \"principal=[running as], run_by_principal=[_username]\" : \"principal=[_username]\"; auditTrail.accessGranted(user, \"internal:_action\", message, null);"
  },
  {
    "devdecision": "Manual",
    "id": 75065,
    "v2": "String role = randomAlphaOfLengthBetween(1, 6); auditTrail.accessDenied(user, \"_action\", message, new String[] { role }); String userInfo = (runAs ? \"principal=[running as], run_by_principal=[_username]\" : \"principal=[_username]\") + \", roles=[\" + role + \"]\";",
    "resolution": "String role = randomAlphaOfLengthBetween(1, 6); auditTrail.accessDenied(user, \"_action\", message, new String[] { role }, null); String userInfo = (runAs ? \"principal=[running as], run_by_principal=[_username]\" : \"principal=[_username]\") + \", roles=[\" + role + \"]\";",
    "conflict": "String userInfo = runAs ? \"principal=[running as], run_by_principal=[_username]\" : \"principal=[_username]\"; auditTrail.accessDenied(user, \"_action\", message, null);"
  },
  {
    "devdecision": "Manual",
    "id": 75076,
    "v2": "() -> authorize(createAuthentication(user), \"indices:a\", request), \"indices:a\", \"test user\"); verify(auditTrail).accessDenied(user, \"indices:a\", request, Role.EMPTY.names());",
    "resolution": "() -> authorize(createAuthentication(user), action, request), action, \"test user\"); verify(auditTrail).accessDenied(user, action, request, Role.EMPTY.names(), null);",
    "conflict": "() -> authorize(createAuthentication(user), action, request), action, \"test user\"); verify(auditTrail).accessDenied(user, action, request, null);"
  },
  {
    "devdecision": "Manual",
    "id": 75078,
    "v2": "() -> authorize(createAuthentication(user), \"indices:a\", request), \"indices:a\", \"test user\"); verify(auditTrail).accessDenied(user, \"indices:a\", request, new String[] { role.getName() });",
    "resolution": "() -> authorize(createAuthentication(user), action, request), action, \"test user\"); verify(auditTrail).accessDenied(user, action, request, new String[] { role.getName() }, null);",
    "conflict": "() -> authorize(createAuthentication(user), action, request), action, \"test user\"); verify(auditTrail).accessDenied(user, action, request, null);"
  },
  {
    "devdecision": "Manual",
    "id": 75100,
    "v2": "verify(auditTrail).accessDenied(user, DeleteAction.NAME, request, new String[] { role.getName() }); // alias-1 delete verify(auditTrail).accessDenied(user, IndexAction.NAME, request, new String[] { role.getName() }); // alias-2 index verify(auditTrail).accessGranted(user, action, request, new String[] { role.getName() }); // bulk request is allowed",
    "resolution": "verify(auditTrail).accessDenied(user, DeleteAction.NAME, request, new String[] { role.getName() }, null); // alias-1 delete verify(auditTrail).accessDenied(user, IndexAction.NAME, request, new String[] { role.getName() }, null); // alias-2 index verify(auditTrail).accessGranted(user, action, request, new String[] { role.getName() }, null); // bulk request is allowed",
    "conflict": "verify(auditTrail).accessDenied(user, DeleteAction.NAME, request, null); // alias-1 delete verify(auditTrail).accessDenied(user, IndexAction.NAME, request, null); // alias-2 index verify(auditTrail).accessGranted(user, action, request, null); // bulk request is allowed"
  },
  {
    "devdecision": "Manual",
    "id": 75101,
    "v2": "verify(auditTrail, Mockito.times(2)).accessDenied(user, DeleteAction.NAME, request, new String[] { role.getName() }); // both // deletes // should fail verify(auditTrail).accessGranted(user, action, request, new String[] { role.getName() }); // bulk request is allowed",
    "resolution": "verify(auditTrail, Mockito.times(2)).accessDenied(user, DeleteAction.NAME, request, new String[] { role.getName() }, null); // both // deletes // should fail verify(auditTrail).accessGranted(user, action, request, new String[] { role.getName() }, null); // bulk request is allowed",
    "conflict": "verify(auditTrail, Mockito.times(2)).accessDenied(user, DeleteAction.NAME, request, null); // both deletes should fail verify(auditTrail).accessGranted(user, action, request, null); // bulk request is allowed"
  },
  {
    "devdecision": "Manual",
    "id": 75105,
    "v2": "verify(auditTrail).accessDenied(user, action, clearScrollRequest, new String[] { role.getName() });",
    "resolution": "verify(auditTrail).accessDenied(user, action, clearScrollRequest, new String[] { role.getName() }, null);",
    "conflict": "verify(auditTrail).accessDenied(user, action, clearScrollRequest, null); }  private BiFunction<IndicesOptions, String[], IndicesAccessControl> getAccessControlResolver() { return threadContext.getTransient(AuthorizationService.INDICES_PERMISSIONS_RESOLVER_KEY);"
  },
  {
    "devdecision": "Combination",
    "id": 75114,
    "v2": "",
    "resolution": "import org.elasticsearch.xpack.sql.analysis.catalog.FilteredCatalog; import org.elasticsearch.xpack.sql.SecurityCatalogFilter; import org.elasticsearch.xpack.sql.plugin.SqlLicenseChecker; import org.elasticsearch.xpack.sql.plugin.SqlPlugin;",
    "conflict": "import org.elasticsearch.xpack.security.crypto.CryptoService; import org.elasticsearch.xpack.sql.analysis.catalog.FilteredCatalog; import org.elasticsearch.xpack.sql.SecurityCatalogFilter; import org.elasticsearch.xpack.sql.plugin.SqlLicenseChecker; import org.elasticsearch.xpack.sql.plugin.SqlPlugin;"
  },
  {
    "devdecision": "Version 2",
    "id": 75139,
    "v2": "",
    "resolution": "",
    "conflict": "authorize(createAuthentication(XPackUser.INSTANCE), action, request); verify(auditTrail).accessGranted(XPackUser.INSTANCE, action, request, null); assertThat(request.indices(), arrayContaining(\".security\"));  request = new SearchRequest(\"_all\");"
  },
  {
    "devdecision": "Combination",
    "id": 75165,
    "v2": "import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator; import org.elasticsearch.test.InternalAggregationTestCase;",
    "resolution": "import org.elasticsearch.search.aggregations.InternalAggregations; import org.elasticsearch.search.aggregations.InternalMultiBucketAggregationTestCase; import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;",
    "conflict": "import org.elasticsearch.search.aggregations.InternalAggregations; import org.elasticsearch.search.aggregations.InternalMultiBucketAggregationTestCase; import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator; import org.junit.Before;"
  },
  {
    "devdecision": "Version 2",
    "id": 75191,
    "v2": "",
    "resolution": "",
    "conflict": "public int hashCode() { return Objects.hash(pattern); }  @Override"
  },
  {
    "devdecision": "Version 2",
    "id": 75192,
    "v2": "@Override public int hashCode() { return Objects.hash(pattern); }",
    "resolution": "@Override public int hashCode() { return Objects.hash(pattern); }",
    "conflict": ""
  },
  {
    "devdecision": "Manual",
    "id": 75196,
    "v2": "return new InternalAvg(name, randomDoubleBetween(0, 100000, true), randomNonNegativeLong() % 100000, randomNumericDocValueFormat(), pipelineAggregators, metaData);",
    "resolution": "DocValueFormat formatter = randomNumericDocValueFormat(); long count = frequently() ? randomNonNegativeLong() % 100000 : 0; return new InternalAvg(name, randomDoubleBetween(0, 100000, true), count, formatter, pipelineAggregators, metaData);",
    "conflict": "DocValueFormat formatter = randomFrom(new DocValueFormat.Decimal(\"###.##\"), DocValueFormat.BOOLEAN, DocValueFormat.RAW); long count = frequently() ? randomNonNegativeLong() % 100000 : 0; return new InternalAvg(name, randomDoubleBetween(0, 100000, true), count, formatter, pipelineAggregators, metaData);"
  },
  {
    "devdecision": "Combination",
    "id": 75208,
    "v2": "import org.elasticsearch.ElasticsearchStatusException; import org.elasticsearch.action.DocWriteRequest; import org.elasticsearch.action.DocWriteResponse;",
    "resolution": "import org.elasticsearch.action.DocWriteRequest; import org.elasticsearch.action.DocWriteResponse; import org.elasticsearch.action.delete.DeleteRequest; import org.elasticsearch.action.delete.DeleteResponse; import org.elasticsearch.ElasticsearchStatusException;",
    "conflict": "import org.elasticsearch.action.DocWriteResponse; import org.elasticsearch.action.delete.DeleteRequest; import org.elasticsearch.action.delete.DeleteResponse;"
  },
  {
    "devdecision": "Version 2",
    "id": 75227,
    "v2": "final Version version = executeHandshake(node, channel, handshakeTimeout); transportServiceAdapter.onConnectionOpened(node); return new NodeChannels(nodeChannels, version); // clone the channels - we now have the correct version",
    "resolution": "final Version version = executeHandshake(node, channel, handshakeTimeout); transportServiceAdapter.onConnectionOpened(node); return new NodeChannels(nodeChannels, version); // clone the channels - we now have the correct version",
    "conflict": "Version version = executeHandshake(node, channel, handshakeTimeout); transportServiceAdapter.onConnectionOpened(node); return new NodeChannels(nodeChannels, version);"
  },
  {
    "devdecision": "Version 2",
    "id": 75269,
    "v2": "* {@link IndexShard#acquireReplicaOperationLock(long, ActionListener, String)} * * @param shardRequest the request to the replica shard * @param replica      the replica shard to perform the operation on",
    "resolution": "* {@link IndexShard#acquireReplicaOperationLock(long, ActionListener, String)} * * @param shardRequest the request to the replica shard * @param replica      the replica shard to perform the operation on",
    "conflict": "* {@link #acquireReplicaOperationLock(ShardId, long, String, ActionListener)}"
  },
  {
    "devdecision": "Version 2",
    "id": 75270,
    "v2": "if (finalFailure == null) { listener.onResponse(TransportResponse.Empty.INSTANCE); } else { listener.onFailure(finalFailure); }",
    "resolution": "if (finalFailure == null) { listener.onResponse(TransportResponse.Empty.INSTANCE); } else { listener.onFailure(finalFailure); }",
    "conflict": "listener.onResponse(Empty.INSTANCE);"
  },
  {
    "devdecision": "Manual",
    "id": 75280,
    "v2": "analysisRegistry, engineFactory.get(), circuitBreakerService, bigArrays, threadPool, scriptService, indicesQueriesRegistry, clusterService, client, queryCache, store, eventListener, searcherWrapperFactory, mapperRegistry, indicesFieldDataCache, searchOperationListeners, indexOperationListeners);",
    "resolution": "analysisRegistry, engineFactory.get(), circuitBreakerService, bigArrays, threadPool, scriptService, indicesQueriesRegistry, clusterService, client, queryCache, store, eventListener, searcherWrapperFactory, mapperRegistry, indicesFieldDataCache, globalCheckpointSyncer, searchOperationListeners, indexOperationListeners);",
    "conflict": "analysisRegistry, engineFactory.get(), servicesProvider, queryCache, store, eventListener, searcherWrapperFactory, mapperRegistry, indicesFieldDataCache, globalCheckpointSyncer, searchOperationListeners, indexOperationListeners);"
  },
  {
    "devdecision": "Concatenation",
    "id": 75282,
    "v2": "private final ScriptService scriptService; private final IndicesQueriesRegistry queryRegistry; private final ClusterService clusterService; private final Client client;",
    "resolution": "private final ScriptService scriptService; private final IndicesQueriesRegistry queryRegistry; private final ClusterService clusterService; private final Client client;private final AsyncGlobalCheckpointTask globalCheckpointTask;",
    "conflict": "private final AsyncGlobalCheckpointTask globalCheckpointTask;"
  },
  {
    "devdecision": "Manual",
    "id": 75287,
    "v2": "this(type, id, uid, Versions.MATCH_ANY, VersionType.INTERNAL, Origin.PRIMARY, System.nanoTime()); }  public Delete(Delete template, VersionType versionType) { this(template.type(), template.id(), template.uid(), template.version(), versionType, template.origin(), template.startTime());",
    "resolution": "this(type, id, uid, SequenceNumbersService.UNASSIGNED_SEQ_NO, Versions.MATCH_ANY, VersionType.INTERNAL, Origin.PRIMARY, System.nanoTime());",
    "conflict": "this(type, id, uid, SequenceNumbersService.UNASSIGNED_SEQ_NO, Versions.MATCH_ANY, VersionType.INTERNAL, Origin.PRIMARY, System.nanoTime(), false);"
  },
  {
    "devdecision": "Manual",
    "id": 75295,
    "v2": "public Delete(Engine.Delete delete, Engine.DeleteResult deleteResult) { this.uid = delete.uid(); this.version = deleteResult.getVersion(); this.versionType = delete.versionType();",
    "resolution": "public Delete(Engine.Delete delete, Engine.DeleteResult deleteResult) { this(delete.uid(), deleteResult.getSeqNo(), deleteResult.getVersion(), delete.versionType());",
    "conflict": "public Delete(Engine.Delete delete) { this(delete.uid(), delete.seqNo(), delete.version(), delete.versionType());"
  },
  {
    "devdecision": "Manual",
    "id": 75303,
    "v2": "final IndexService service = createIndexService(\"metadata verification\", metaData, indicesQueryCache, indicesFieldDataCache, emptyList());",
    "resolution": "final IndexService service = createIndexService(\"metadata verification\", metaData, indicesQueryCache, indicesFieldDataCache, emptyList(), s -> {});",
    "conflict": "final IndexService service = createIndexService(\"metadata verification\", nodeServicesProvider, metaData, indicesQueryCache, indicesFieldDataCache, Collections.emptyList(), s -> { });"
  },
  {
    "devdecision": "Manual",
    "id": 75328,
    "v2": "create = new Engine.Index(newUid(\"1\"), doc, indexResult.getVersion(), create.versionType().versionTypeForReplicationAndRecovery(), REPLICA, 0, -1, false); indexResult = replicaEngine.index(create); assertThat(indexResult.getVersion(), equalTo(1L));",
    "resolution": "create = new Engine.Index(newUid(\"1\"), doc, indexResult.getSeqNo(), indexResult.getVersion(), create.versionType().versionTypeForReplicationAndRecovery(), REPLICA, 0, -1, false); indexResult = replicaEngine.index(create); assertThat(indexResult.getVersion(), equalTo(1L));",
    "conflict": "create = new Engine.Index(newUid(\"1\"), doc, create.seqNo(), create.version(), create.versionType().versionTypeForReplicationAndRecovery(), REPLICA, 0, -1, false); replicaEngine.index(create); assertThat(create.version(), equalTo(1L));"
  },
  {
    "devdecision": "Manual",
    "id": 75329,
    "v2": "index = new Engine.Index(newUid(\"1\"), doc, indexResult.getVersion(), index.versionType().versionTypeForReplicationAndRecovery(), REPLICA, 0, -1, false); indexResult = replicaEngine.index(index); assertThat(indexResult.getVersion(), equalTo(1L));",
    "resolution": "index = new Engine.Index(newUid(\"1\"), doc, indexResult.getSeqNo(), indexResult.getVersion(), index.versionType().versionTypeForReplicationAndRecovery(), REPLICA, 0, -1, false); indexResult = replicaEngine.index(index); assertThat(indexResult.getVersion(), equalTo(1L));",
    "conflict": "index = new Engine.Index(newUid(\"1\"), doc, index.seqNo(), index.version(), index.versionType().versionTypeForReplicationAndRecovery(), REPLICA, 0, -1, false); replicaEngine.index(index); assertThat(index.version(), equalTo(1L));"
  },
  {
    "devdecision": "Manual",
    "id": 75337,
    "v2": "delete = new Engine.Delete(\"test\", \"1\", newUid(\"1\"), 2L, VersionType.INTERNAL, PRIMARY, 0); deleteResult = engine.delete(delete); assertThat(deleteResult.getVersion(), equalTo(3L));",
    "resolution": "delete = new Engine.Delete(\"test\", \"1\", newUid(\"1\"), SequenceNumbersService.UNASSIGNED_SEQ_NO, 2L, VersionType.INTERNAL, PRIMARY, 0); deleteResult = engine.delete(delete); assertThat(deleteResult.getVersion(), equalTo(3L));",
    "conflict": "delete = new Engine.Delete(\"test\", \"1\", newUid(\"1\"), SequenceNumbersService.UNASSIGNED_SEQ_NO, 2L, VersionType.INTERNAL, PRIMARY, 0, false); engine.delete(delete); assertThat(delete.version(), equalTo(3L));"
  },
  {
    "devdecision": "Combination",
    "id": 75347,
    "v2": "Engine.Index firstIndexRequest = new Engine.Index(newUid(Integer.toString(i)), doc, Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false); Engine.IndexResult indexResult = engine.index(firstIndexRequest); assertThat(indexResult.getVersion(), equalTo(1L));",
    "resolution": "Engine.Index firstIndexRequest = new Engine.Index(newUid(Integer.toString(i)), doc, SequenceNumbersService.UNASSIGNED_SEQ_NO, Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false); Engine.IndexResult indexResult = engine.index(firstIndexRequest); assertThat(indexResult.getVersion(), equalTo(1L));",
    "conflict": "Engine.Index firstIndexRequest = new Engine.Index(newUid(Integer.toString(i)), doc, SequenceNumbersService.UNASSIGNED_SEQ_NO, Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false); engine.index(firstIndexRequest); assertThat(firstIndexRequest.version(), equalTo(1L));"
  },
  {
    "devdecision": "Combination",
    "id": 75348,
    "v2": "Engine.Index firstIndexRequest = new Engine.Index(newUid(Integer.toString(i)), doc, Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false); Engine.IndexResult indexResult = engine.index(firstIndexRequest); assertThat(indexResult.getVersion(), equalTo(1L));",
    "resolution": "Engine.Index firstIndexRequest = new Engine.Index(newUid(Integer.toString(i)), doc, SequenceNumbersService.UNASSIGNED_SEQ_NO, Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false); Engine.IndexResult indexResult = engine.index(firstIndexRequest); assertThat(indexResult.getVersion(), equalTo(1L));",
    "conflict": "Engine.Index firstIndexRequest = new Engine.Index(newUid(Integer.toString(i)), doc, SequenceNumbersService.UNASSIGNED_SEQ_NO, Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false); engine.index(firstIndexRequest); assertThat(firstIndexRequest.version(), equalTo(1L));"
  },
  {
    "devdecision": "Combination",
    "id": 75349,
    "v2": "Engine.Index firstIndexRequest = new Engine.Index(newUid(Integer.toString(i)), doc, Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false); Engine.IndexResult indexResult = engine.index(firstIndexRequest); assertThat(indexResult.getVersion(), equalTo(1L));",
    "resolution": "Engine.Index firstIndexRequest = new Engine.Index(newUid(Integer.toString(i)), doc, SequenceNumbersService.UNASSIGNED_SEQ_NO, Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false); Engine.IndexResult indexResult = engine.index(firstIndexRequest); assertThat(indexResult.getVersion(), equalTo(1L));",
    "conflict": "Engine.Index firstIndexRequest = new Engine.Index(newUid(Integer.toString(i)), doc, SequenceNumbersService.UNASSIGNED_SEQ_NO, Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false); engine.index(firstIndexRequest); assertThat(firstIndexRequest.version(), equalTo(1L));"
  },
  {
    "devdecision": "Combination",
    "id": 75350,
    "v2": "Engine.Index firstIndexRequest = new Engine.Index(newUid(Integer.toString(i)), doc, Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false); Engine.IndexResult indexResult = engine.index(firstIndexRequest); assertThat(indexResult.getVersion(), equalTo(1L));",
    "resolution": "Engine.Index firstIndexRequest = new Engine.Index(newUid(Integer.toString(i)), doc, SequenceNumbersService.UNASSIGNED_SEQ_NO, Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false); Engine.IndexResult indexResult = engine.index(firstIndexRequest); assertThat(indexResult.getVersion(), equalTo(1L));",
    "conflict": "Engine.Index firstIndexRequest = new Engine.Index(newUid(Integer.toString(i)), doc, SequenceNumbersService.UNASSIGNED_SEQ_NO, Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false); engine.index(firstIndexRequest); assertThat(firstIndexRequest.version(), equalTo(1L));"
  },
  {
    "devdecision": "Combination",
    "id": 75351,
    "v2": "Engine.Index firstIndexRequest = new Engine.Index(newUid(uuidValue), doc, 1, VersionType.EXTERNAL, PRIMARY, System.nanoTime(), -1, false); Engine.IndexResult indexResult = engine.index(firstIndexRequest); assertThat(indexResult.getVersion(), equalTo(1L));",
    "resolution": "Engine.Index firstIndexRequest = new Engine.Index(newUid(uuidValue), doc, SequenceNumbersService.UNASSIGNED_SEQ_NO, 1, VersionType.EXTERNAL, PRIMARY, System.nanoTime(), -1, false); Engine.IndexResult indexResult = engine.index(firstIndexRequest); assertThat(indexResult.getVersion(), equalTo(1L));",
    "conflict": "Engine.Index firstIndexRequest = new Engine.Index(newUid(uuidValue), doc, SequenceNumbersService.UNASSIGNED_SEQ_NO, 1, VersionType.EXTERNAL, PRIMARY, System.nanoTime(), -1, false); engine.index(firstIndexRequest); assertThat(firstIndexRequest.version(), equalTo(1L));"
  },
  {
    "devdecision": "Manual",
    "id": 75353,
    "v2": "IndexAnalyzers indexAnalyzers = null; NamedAnalyzer defaultAnalyzer = new NamedAnalyzer(\"default\", AnalyzerScope.INDEX, new StandardAnalyzer()); indexAnalyzers = new IndexAnalyzers(indexSettings, defaultAnalyzer, defaultAnalyzer, defaultAnalyzer, Collections.emptyMap());",
    "resolution": "NamedAnalyzer defaultAnalyzer = new NamedAnalyzer(\"default\", AnalyzerScope.INDEX, new StandardAnalyzer()); IndexAnalyzers indexAnalyzers = new IndexAnalyzers(indexSettings, defaultAnalyzer, defaultAnalyzer, defaultAnalyzer, Collections.emptyMap()); SimilarityService similarityService = new SimilarityService(indexSettings, Collections.emptyMap());",
    "conflict": "NamedAnalyzer defaultAnalyzer = new NamedAnalyzer(\"default\", new StandardAnalyzer()); IndexAnalyzers indexAnalyzers = new IndexAnalyzers(indexSettings, defaultAnalyzer, defaultAnalyzer, defaultAnalyzer, Collections.emptyMap());"
  },
  {
    "devdecision": "Combination",
    "id": 75354,
    "v2": "Engine.Index firstIndexRequest = new Engine.Index(newUid(Integer.toString(i)), doc, Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false); Engine.IndexResult index = engine.index(firstIndexRequest); assertThat(index.getVersion(), equalTo(1L));",
    "resolution": "Engine.Index firstIndexRequest = new Engine.Index(newUid(Integer.toString(i)), doc, SequenceNumbersService.UNASSIGNED_SEQ_NO, Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false); Engine.IndexResult index = engine.index(firstIndexRequest); assertThat(index.getVersion(), equalTo(1L));",
    "conflict": "Engine.Index firstIndexRequest = new Engine.Index(newUid(Integer.toString(i)), doc, SequenceNumbersService.UNASSIGNED_SEQ_NO, Versions.MATCH_DELETED, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false); engine.index(firstIndexRequest); assertThat(firstIndexRequest.version(), equalTo(1L));"
  },
  {
    "devdecision": "Combination",
    "id": 75355,
    "v2": "Engine.Index firstIndexRequest = new Engine.Index(newUid(Integer.toString(i)), doc, Versions.MATCH_ANY, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false); Engine.IndexResult indexResult = engine.index(firstIndexRequest); assertThat(indexResult.getVersion(), equalTo(1L));",
    "resolution": "Engine.Index firstIndexRequest = new Engine.Index(newUid(Integer.toString(i)), doc, SequenceNumbersService.UNASSIGNED_SEQ_NO, Versions.MATCH_ANY, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false); Engine.IndexResult indexResult = engine.index(firstIndexRequest); assertThat(indexResult.getVersion(), equalTo(1L));",
    "conflict": "Engine.Index firstIndexRequest = new Engine.Index(newUid(Integer.toString(i)), doc, SequenceNumbersService.UNASSIGNED_SEQ_NO, Versions.MATCH_ANY, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false); engine.index(firstIndexRequest); assertThat(firstIndexRequest.version(), equalTo(1L));"
  },
  {
    "devdecision": "Combination",
    "id": 75356,
    "v2": "Engine.Index firstIndexRequest = new Engine.Index(newUid(Integer.toString(0)), doc, Versions.MATCH_ANY, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false); Engine.IndexResult index = engine.index(firstIndexRequest); assertThat(index.getVersion(), equalTo(2L));",
    "resolution": "Engine.Index firstIndexRequest = new Engine.Index(newUid(Integer.toString(0)), doc, SequenceNumbersService.UNASSIGNED_SEQ_NO, Versions.MATCH_ANY, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false); Engine.IndexResult index = engine.index(firstIndexRequest); assertThat(index.getVersion(), equalTo(2L));",
    "conflict": "Engine.Index firstIndexRequest = new Engine.Index(newUid(Integer.toString(0)), doc, SequenceNumbersService.UNASSIGNED_SEQ_NO, Versions.MATCH_ANY, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false); engine.index(firstIndexRequest); assertThat(firstIndexRequest.version(), equalTo(2L));"
  },
  {
    "devdecision": "Manual",
    "id": 75358,
    "v2": "index = new Engine.Index(newUid(\"1\"), doc, indexResult.getVersion(), index.versionType().versionTypeForReplicationAndRecovery(), REPLICA, System.nanoTime(), autoGeneratedIdTimestamp, isRetry); indexResult = replicaEngine.index(index); assertThat(indexResult.hasFailure(), equalTo(false));",
    "resolution": "index = new Engine.Index(newUid(\"1\"), doc, indexResult.getSeqNo(), indexResult.getVersion(), index.versionType().versionTypeForReplicationAndRecovery(), REPLICA, System.nanoTime(), autoGeneratedIdTimestamp, isRetry); indexResult = replicaEngine.index(index); assertThat(indexResult.hasFailure(), equalTo(false));",
    "conflict": "index = new Engine.Index(newUid(\"1\"), doc, index.seqNo(), index.version(), index.versionType().versionTypeForReplicationAndRecovery(), REPLICA, System.nanoTime(), autoGeneratedIdTimestamp, isRetry); replicaEngine.index(index);"
  },
  {
    "devdecision": "Combination",
    "id": 75361,
    "v2": "Engine.Index firstIndexRequest = new Engine.Index(newUid(Integer.toString(i)), doc, Versions.MATCH_ANY, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false); Engine.IndexResult indexResult = primaryEngine.index(firstIndexRequest); assertThat(indexResult.getVersion(), equalTo(1L));",
    "resolution": "Engine.Index firstIndexRequest = new Engine.Index(newUid(Integer.toString(i)), doc, SequenceNumbersService.UNASSIGNED_SEQ_NO, Versions.MATCH_ANY, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false); Engine.IndexResult indexResult = primaryEngine.index(firstIndexRequest); assertThat(indexResult.getVersion(), equalTo(1L));",
    "conflict": "Engine.Index firstIndexRequest = new Engine.Index(newUid(Integer.toString(i)), doc, SequenceNumbersService.UNASSIGNED_SEQ_NO, Versions.MATCH_ANY, VersionType.INTERNAL, PRIMARY, System.nanoTime(), -1, false); primaryEngine.index(firstIndexRequest); assertThat(firstIndexRequest.version(), equalTo(1L));"
  },
  {
    "devdecision": "Manual",
    "id": 75364,
    "v2": "public synchronized MockIndexService createIndex(IndexMetaData indexMetaData, List<IndexEventListener> buildInIndexListener) throws IOException {",
    "resolution": "public synchronized MockIndexService createIndex( IndexMetaData indexMetaData, List<IndexEventListener> buildInIndexListener, Consumer<ShardId> globalCheckPointSyncer) throws IOException {",
    "conflict": "public synchronized MockIndexService createIndex(NodeServicesProvider nodeServicesProvider, IndexMetaData indexMetaData, List<IndexEventListener> buildInIndexListener, Consumer<ShardId> globalCheckPointSyncer) throws IOException {"
  },
  {
    "devdecision": "Version 2",
    "id": 75385,
    "v2": "for (ScriptFieldsContext.ScriptField field : scriptFields) { subSearchContext.scriptFields().add(field);",
    "resolution": "for (ScriptFieldsContext.ScriptField field : scriptFields) { subSearchContext.scriptFields().add(field);",
    "conflict": "if (scriptFields != null) { for (ScriptFieldsContext.ScriptField field : scriptFields) { subSearchContext.scriptFields().add(field); }"
  },
  {
    "devdecision": "Manual",
    "id": 75398,
    "v2": "UpdateResponse updateResponse = new UpdateResponse(indexResponse.getShardInfo(), indexResponse.getShardId(), indexResponse.getType(), indexResponse.getId(), indexResponse.getVersion(), indexResponse.getResult()); if ((updateRequest.fetchSource() != null && updateRequest.fetchSource().fetchSource()) || (updateRequest.fields() != null && updateRequest.fields().length > 0)) {",
    "resolution": "UpdateResponse updateResponse = new UpdateResponse(indexResponse.getShardInfo(), indexResponse.getShardId(), indexResponse.getType(), indexResponse.getId(), indexResponse.getSeqNo(), indexResponse.getVersion(), indexResponse.getResult()); if ((updateRequest.fetchSource() != null && updateRequest.fetchSource().fetchSource()) || (updateRequest.fields() != null && updateRequest.fields().length > 0)) {",
    "conflict": "UpdateResponse updateResponse = new UpdateResponse(indexResponse.getShardInfo(), indexResponse.getShardId(), indexResponse.getType(), indexResponse.getId(), indexResponse.getSeqNo(), indexResponse.getVersion(), indexResponse.isCreated()); if (updateRequest.fields() != null && updateRequest.fields().length > 0) {"
  },
  {
    "devdecision": "Combination",
    "id": 75403,
    "v2": "builder.append(\",result=\").append(getResult().getLowercase()); builder.append(\",shards=\").append(Strings.toString(getShardInfo(), true));",
    "resolution": "builder.append(\",result=\").append(getResult().getLowercase()); builder.append(\",seqNo=\").append(getSeqNo()); builder.append(\",shards=\").append(Strings.toString(getShardInfo(), true));",
    "conflict": "builder.append(\",created=\").append(created); builder.append(\",seqNo=\").append(getSeqNo()); builder.append(\",shards=\").append(getShardInfo());"
  },
  {
    "devdecision": "Combination",
    "id": 75410,
    "v2": "transportService.sendRequest(node, transportReplicaAction, new ConcreteShardRequest<>(request, replica.allocationId().getId()), transportOptions, new ActionListenerResponseHandler<>(listener, () -> TransportResponse.Empty.INSTANCE));",
    "resolution": "transportService.sendRequest(node, transportReplicaAction, new ConcreteShardRequest<>(request, replica.allocationId().getId()), transportOptions, new ActionListenerResponseHandler<>(listener, ReplicaResponse::new));",
    "conflict": "transportService.sendRequest(node, transportReplicaAction, request, transportOptions, new ActionListenerResponseHandler<>(listener, ReplicaResponse::new));"
  },
  {
    "devdecision": "Manual",
    "id": 75411,
    "v2": "UpdateResponse update = new UpdateResponse(response.getShardInfo(), response.getShardId(), response.getType(), response.getId(), response.getVersion(), response.getResult()); if ((request.fetchSource() != null && request.fetchSource().fetchSource()) || (request.fields() != null && request.fields().length > 0)) {",
    "resolution": "UpdateResponse update = new UpdateResponse(response.getShardInfo(), response.getShardId(), response.getType(), response.getId(), response.getSeqNo(), response.getVersion(), response.getResult()); if ((request.fetchSource() != null && request.fetchSource().fetchSource()) || (request.fields() != null && request.fields().length > 0)) {",
    "conflict": "UpdateResponse update = new UpdateResponse(response.getShardInfo(), response.getShardId(), response.getType(), response.getId(), response.getSeqNo(), response.getVersion(), response.isCreated()); if (request.fields() != null && request.fields().length > 0) {"
  },
  {
    "devdecision": "Manual",
    "id": 75419,
    "v2": "public Index(Term uid, ParsedDocument doc, long version, VersionType versionType, Origin origin, long startTime, long autoGeneratedIdTimestamp, boolean isRetry) { super(uid, version, versionType, origin, startTime);",
    "resolution": "public Index(Term uid, ParsedDocument doc, long seqNo, long version, VersionType versionType, Origin origin, long startTime, long autoGeneratedIdTimestamp, boolean isRetry) { super(uid, seqNo, version, versionType, origin, startTime);",
    "conflict": "public Index(Term uid, ParsedDocument doc, long seqNo, long version, VersionType versionType, Origin origin, long startTime) { super(uid, seqNo, version, versionType, origin, startTime);"
  },
  {
    "devdecision": "Combination",
    "id": 75422,
    "v2": "",
    "resolution": "import static org.elasticsearch.index.seqno.SequenceNumbersService.NO_OPS_PERFORMED;",
    "conflict": "import static org.elasticsearch.index.seqno.SequenceNumbersService.NO_OPS_PERFORMED;  /** * */"
  },
  {
    "devdecision": "Manual",
    "id": 75434,
    "v2": "if (format >= FORMAT_AUTO_GENERATED_IDS) { this.autoGeneratedIdTimestamp = in.readLong(); } else { this.autoGeneratedIdTimestamp = IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP;",
    "resolution": "if (format >= FORMAT_AUTO_GENERATED_IDS) { this.autoGeneratedIdTimestamp = in.readLong(); } else { this.autoGeneratedIdTimestamp = IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP;",
    "conflict": "if (format >= 7) { seqNo = in.readVLong();"
  },
  {
    "devdecision": "Concatenation",
    "id": 75443,
    "v2": "RoutingTable initialRoutingTable = RoutingTable.builder() .addAsNew(metaData.index(\"test\")) .build();",
    "resolution": "RoutingTable initialRoutingTable = RoutingTable.builder() .addAsNew(metaData.index(\"test\")) .build();RoutingTable routingTable = RoutingTable.builder() .addAsNew(metaData.index(\"test\")) .build();",
    "conflict": "RoutingTable routingTable = RoutingTable.builder() .addAsNew(metaData.index(\"test\")) .build();"
  },
  {
    "devdecision": "Version 2",
    "id": 75448,
    "v2": ".add(newNode(\"node0\", VersionUtils.getPreviousVersion())) .add(newNode(\"new1\")) .add(newNode(\"new0\"))).build();",
    "resolution": ".add(newNode(\"node0\", VersionUtils.getPreviousVersion())) .add(newNode(\"new1\")) .add(newNode(\"new0\"))).build();",
    "conflict": ".put(newNode(\"node0\", VersionUtils.getPreviousVersion())) .put(newNode(\"new1\")) .put(newNode(\"new0\"))).build();"
  },
  {
    "devdecision": "Version 2",
    "id": 75449,
    "v2": ".add(newNode(\"new2\")) .add(newNode(\"new1\")) .add(newNode(\"new0\"))).build();",
    "resolution": ".add(newNode(\"new2\")) .add(newNode(\"new1\")) .add(newNode(\"new0\"))).build();",
    "conflict": ".put(newNode(\"new2\")) .put(newNode(\"new1\")) .put(newNode(\"new0\"))).build();"
  },
  {
    "devdecision": "Combination",
    "id": 75488,
    "v2": "import org.elasticsearch.index.mapper.SourceFieldMapper; import org.elasticsearch.index.mapper.UidFieldMapper; import org.elasticsearch.index.shard.RefreshListeners;",
    "resolution": "import org.elasticsearch.index.mapper.SourceFieldMapper; import org.elasticsearch.index.mapper.UidFieldMapper; import org.elasticsearch.index.seqno.SequenceNumbersService;",
    "conflict": "import org.elasticsearch.index.mapper.internal.SourceFieldMapper; import org.elasticsearch.index.mapper.internal.UidFieldMapper; import org.elasticsearch.index.seqno.SequenceNumbersService;"
  },
  {
    "devdecision": "Version 2",
    "id": 75491,
    "v2": "@Override public void markShardCopyAsStale(ShardId shardId, String allocationId, long primaryTerm, Runnable onSuccess, Consumer<Exception> onPrimaryDemoted, Consumer<Exception> onIgnoredFailure) { throw new UnsupportedOperationException(); }",
    "resolution": "@Override public void markShardCopyAsStale(ShardId shardId, String allocationId, long primaryTerm, Runnable onSuccess, Consumer<Exception> onPrimaryDemoted, Consumer<Exception> onIgnoredFailure) { throw new UnsupportedOperationException(); }",
    "conflict": ""
  },
  {
    "devdecision": "Version 1",
    "id": 75507,
    "v2": "logger.warn(formattedMsg); } else { logger.warn(msg, params);",
    "resolution": "logger.warn(formattedMessage); } else { logger.warn(message, params);",
    "conflict": "logger.warn(formattedMessage); } else { logger.warn(message, params);"
  },
  {
    "devdecision": "Combination",
    "id": 75518,
    "v2": "import org.elasticsearch.rest.action.RestActions; import org.elasticsearch.rest.action.RestToXContentListener;",
    "resolution": "import org.elasticsearch.rest.action.RestActions; import org.elasticsearch.rest.action.RestToXContentListener; import org.elasticsearch.search.SearchRequestParsers;",
    "conflict": "import org.elasticsearch.rest.action.support.RestActions; import org.elasticsearch.rest.action.support.RestToXContentListener; import org.elasticsearch.search.SearchRequestParsers;"
  },
  {
    "devdecision": "Combination",
    "id": 75519,
    "v2": "import org.elasticsearch.rest.action.RestActions; import org.elasticsearch.rest.action.RestBuilderListener;",
    "resolution": "import org.elasticsearch.rest.action.RestActions; import org.elasticsearch.rest.action.RestBuilderListener; import org.elasticsearch.search.SearchRequestParsers;",
    "conflict": "import org.elasticsearch.rest.action.support.RestActions; import org.elasticsearch.rest.action.support.RestBuilderListener; import org.elasticsearch.search.SearchRequestParsers;"
  },
  {
    "devdecision": "Combination",
    "id": 75520,
    "v2": "",
    "resolution": "private final SearchRequestParsers searchRequestParsers;",
    "conflict": "private final SearchRequestParsers searchRequestParsers; public static final Setting<Integer> INDICES_MAX_CLAUSE_COUNT_SETTING = Setting.intSetting(\"indices.query.bool.max_clause_count\", 1024, 1, Integer.MAX_VALUE, Setting.Property.NodeScope);  // pkg private so tests can mock Class<? extends SearchService> searchServiceImpl = SearchService.class;"
  },
  {
    "devdecision": "Version 1",
    "id": 75522,
    "v2": "// First group by node DiscoveryNodes.Builder discoNodes = DiscoveryNodes.builder(); for (TestNode testNode : this.testNodes) { discoNodes.add(testNode.discoveryNode); } response.setDiscoveryNodes(discoNodes.build());",
    "resolution": "",
    "conflict": ""
  },
  {
    "devdecision": "Manual",
    "id": 75533,
    "v2": "import org.elasticsearch.license.Licensing; import org.elasticsearch.license.XPackLicenseState;",
    "resolution": "import org.elasticsearch.license.LicenseService; import org.elasticsearch.license.Licensing; import org.elasticsearch.license.XPackLicenseState;",
    "conflict": "import org.elasticsearch.license.plugin.Licensing; import org.elasticsearch.license.plugin.core.LicenseService; import org.elasticsearch.license.plugin.core.XPackLicenseState;"
  },
  {
    "devdecision": "Concatenation",
    "id": 75536,
    "v2": "import org.elasticsearch.script.ExecutableScript; import org.elasticsearch.script.Script; import org.elasticsearch.script.ScriptContext; import org.elasticsearch.script.ScriptService; import org.elasticsearch.xpack.security.authc.Authentication;",
    "resolution": "import org.elasticsearch.script.ExecutableScript; import org.elasticsearch.script.Script; import org.elasticsearch.script.ScriptContext; import org.elasticsearch.script.ScriptService; import org.elasticsearch.xpack.security.authc.Authentication;import org.elasticsearch.license.plugin.core.XPackLicenseState;",
    "conflict": "import org.elasticsearch.license.plugin.core.XPackLicenseState;"
  },
  {
    "devdecision": "Manual",
    "id": 75539,
    "v2": "new BasicHeader(AuthenticationService.RUN_AS_USER_HEADER, SecuritySettingsSource.DEFAULT_USER_NAME))) { assertThat(response.getStatusLine().getStatusCode(), is(200)); }",
    "resolution": "new BasicHeader(AuthenticationService.RUN_AS_USER_HEADER, SecuritySettingsSource.DEFAULT_USER_NAME)); assertThat(response.getStatusLine().getStatusCode(), is(200));",
    "conflict": "new BasicHeader(InternalAuthenticationService.RUN_AS_USER_HEADER, SecuritySettingsSource.DEFAULT_USER_NAME)); assertThat(response.getStatusLine().getStatusCode(), is(200));"
  },
  {
    "devdecision": "Combination",
    "id": 75548,
    "v2": "import com.unboundid.ldap.sdk.LDAPException; import org.elasticsearch.ElasticsearchException; import org.elasticsearch.common.inject.Inject;",
    "resolution": "import java.util.Map;  import com.unboundid.ldap.sdk.LDAPException; import org.elasticsearch.ElasticsearchException;",
    "conflict": "import java.util.Map;"
  },
  {
    "devdecision": "Combination",
    "id": 75553,
    "v2": "import org.elasticsearch.script.Script; import org.elasticsearch.xpack.common.ScriptServiceProxy;",
    "resolution": "import org.elasticsearch.script.Script; import org.elasticsearch.script.ScriptService; import org.elasticsearch.xpack.watcher.support.WatcherScript;",
    "conflict": "import org.elasticsearch.script.ScriptService; import org.elasticsearch.script.Template; import org.elasticsearch.xpack.watcher.support.WatcherScript;"
  },
  {
    "devdecision": "None",
    "id": 75558,
    "v2": "list.add(SecurityLicensee.class);",
    "resolution": "list.add(FileRolesStore.class); list.add(Realms.class);",
    "conflict": "//TODO why only focus on file audit logs? shouldn't we just check if audit trail is enabled in general? if (AuditTrailModule.fileAuditLoggingEnabled(settings) == true) { list.add(LoggingAuditTrail.class); }"
  },
  {
    "devdecision": "Manual",
    "id": 75567,
    "v2": "public synchronized AmazonS3 client(String endpoint, Protocol protocol, String region, String account, String key, Integer maxRetries, boolean useThrottleRetries) { return cachedWrapper(super.client(endpoint, protocol, region, account, key, maxRetries, useThrottleRetries));",
    "resolution": "public synchronized AmazonS3 client(String endpoint, Protocol protocol, String region, String account, String key, Integer maxRetries, boolean useThrottleRetries, Boolean pathStyleAccess) { return cachedWrapper(super.client(endpoint, protocol, region, account, key, maxRetries, useThrottleRetries, pathStyleAccess));",
    "conflict": "public synchronized AmazonS3 client(String endpoint, Protocol protocol, String region, String account, String key, Integer maxRetries, Boolean pathStyleAccess) { return cachedWrapper(super.client(endpoint, protocol, region, account, key, maxRetries, pathStyleAccess));"
  },
  {
    "devdecision": "Version 1",
    "id": 75568,
    "v2": "CircuitBreakerService circuitBreakerService, @Nullable HttpServer httpServer, ProcessorsRegistry.Builder processorsRegistryBuilder, ClusterService clusterService, SettingsFilter settingsFilter) {",
    "resolution": "CircuitBreakerService circuitBreakerService, ScriptService scriptService, @Nullable HttpServer httpServer, IngestService ingestService, ClusterService clusterService, SettingsFilter settingsFilter) {",
    "conflict": "CircuitBreakerService circuitBreakerService, ScriptService scriptService, @Nullable HttpServer httpServer, IngestService ingestService, ClusterService clusterService, SettingsFilter settingsFilter) {"
  },
  {
    "devdecision": "Version 1",
    "id": 75570,
    "v2": "import org.elasticsearch.ElasticsearchParseException; import org.elasticsearch.cluster.service.ClusterService; import org.elasticsearch.script.ScriptService; import org.elasticsearch.test.ESTestCase; import org.junit.Before;",
    "resolution": "",
    "conflict": ""
  },
  {
    "devdecision": "Version 2",
    "id": 75587,
    "v2": "} else if (e != null && ((indexWriter.isOpen() == false && indexWriter.getTragicException() == e) || (translog.isOpen() == false && translog.getTragicException() == e))) {",
    "resolution": "} else if (e != null && ((indexWriter.isOpen() == false && indexWriter.getTragicException() == e) || (translog.isOpen() == false && translog.getTragicException() == e))) {",
    "conflict": "} else if (t != null && ((indexWriter.isOpen() == false && indexWriter.getTragicException() == t) || (translog.isOpen() == false && translog.getTragicException() == t))) {"
  },
  {
    "devdecision": "Version 2",
    "id": 75609,
    "v2": "",
    "resolution": "",
    "conflict": "import java.nio.ByteBuffer; import java.nio.charset.StandardCharsets; import java.util.Collections; import java.util.Map;"
  },
  {
    "devdecision": "Manual",
    "id": 75615,
    "v2": "List<Processor> onFailureProcessors = readProcessorConfigs(onFailureProcessorConfigs, processorRegistry); String tag = ConfigurationUtils.readOptionalStringProperty(null, null, config, TAG_KEY); Processor processor = factory.create(tag, config);",
    "resolution": "List<Processor> onFailureProcessors = readProcessorConfigs(onFailureProcessorConfigs, processorFactories); String tag = ConfigurationUtils.readOptionalStringProperty(null, null, config, TAG_KEY); Processor processor = factory.create(processorFactories, tag, config);",
    "conflict": "List<Processor> onFailureProcessors = readProcessorConfigs(onFailureProcessorConfigs, processorFactories); Processor processor = factory.create(processorFactories, config);"
  },
  {
    "devdecision": "Manual",
    "id": 75619,
    "v2": "ProcessorsRegistry.Builder builder = new ProcessorsRegistry.Builder(); builder.registerProcessor(\"test_processor\", (registry) -> (tag, config) -> processor); ProcessorsRegistry registry = builder.build(mock(ScriptService.class), mock(ClusterService.class));",
    "resolution": "Map<String, Processor.Factory> registry = Collections.singletonMap(\"test_processor\", (factories, tag, config) -> processor);",
    "conflict": "Map<String, Processor.Factory> registry = Collections.singletonMap(\"test_processor\", (factories, config) -> processor);"
  },
  {
    "devdecision": "Manual",
    "id": 75620,
    "v2": "store = new PipelineStore(Settings.EMPTY); ProcessorsRegistry.Builder registryBuilder = new ProcessorsRegistry.Builder(); registryBuilder.registerProcessor(\"set\", (registry) -> (tag, config) -> {",
    "resolution": "Map<String, Processor.Factory> processorFactories = new HashMap<>(); processorFactories.put(\"set\", (factories, tag, config) -> {",
    "conflict": "Map<String, Processor.Factory> processorFactories = new HashMap<>(); processorFactories.put(\"set\", (factories, config) -> {"
  },
  {
    "devdecision": "Manual",
    "id": 75650,
    "v2": "builder.registerProcessor(\"_name\", (registry) -> (tag, config) -> processor); ProcessorsRegistry registry = builder.build(mock(ScriptService.class), mock(ClusterService.class)); ForEachProcessor.Factory forEachFactory = new ForEachProcessor.Factory(registry);",
    "resolution": "Map<String, Processor.Factory> registry = new HashMap<>(); registry.put(\"_name\", (r, t, c) -> processor); ForEachProcessor.Factory forEachFactory = new ForEachProcessor.Factory();",
    "conflict": "Map<String, Processor.Factory> registry = new HashMap<>(); registry.put(\"_name\", (r, c) -> processor); ForEachProcessor.Factory forEachFactory = new ForEachProcessor.Factory();"
  },
  {
    "devdecision": "Manual",
    "id": 75687,
    "v2": "public static final class Factory implements Processor.Factory { @Override public TestProcessor create(String processorTag, Map<String, Object> config) throws Exception {",
    "resolution": "public static final class Factory implements Processor.Factory { @Override public TestProcessor create(Map<String, Processor.Factory> registry, String processorTag, Map<String, Object> config) throws Exception { return new TestProcessor(processorTag, \"test-processor\", ingestDocument -> {});",
    "conflict": "public static final class Factory extends AbstractProcessorFactory { @Override public TestProcessor doCreate(Map<String, Processor.Factory> registry, String processorTag, Map<String, Object> config) throws Exception {"
  },
  {
    "devdecision": "Manual",
    "id": 75688,
    "v2": "public RestMultiPercolateAction(Settings settings, RestController controller, Client client) { super(settings, client);",
    "resolution": "public RestMultiPercolateAction(Settings settings, RestController controller) { super(settings);",
    "conflict": "public RestMultiPercolateAction(Settings settings, RestController controller, TransportMultiPercolateAction action) { super(settings); this.action = action;"
  },
  {
    "devdecision": "Manual",
    "id": 75689,
    "v2": "public RestPercolateAction(Settings settings, RestController controller, Client client) { super(settings, client);",
    "resolution": "public RestPercolateAction(Settings settings, RestController controller) { super(settings);",
    "conflict": "public RestPercolateAction(Settings settings, RestController controller, TransportPercolateAction action) { super(settings); this.action = action;"
  },
  {
    "devdecision": "Manual",
    "id": 75692,
    "v2": "public RestRethrottleAction(Settings settings, RestController controller, Client client, ClusterService clusterService) { super(settings, client);",
    "resolution": "public RestRethrottleAction(Settings settings, RestController controller, ClusterService clusterService) { super(settings);",
    "conflict": "public RestRethrottleAction(Settings settings, RestController controller, TransportRethrottleAction action, ClusterService clusterService) { super(settings); this.action = action;"
  },
  {
    "devdecision": "Manual",
    "id": 75696,
    "v2": "protected List<DiscoveryNode> buildDynamicNodes(GceComputeService gceComputeService, Settings nodeSettings) { GceUnicastHostsProvider provider = new GceUnicastHostsProvider(nodeSettings, gceComputeService, transportService, new NetworkService(Settings.EMPTY));",
    "resolution": "protected List<DiscoveryNode> buildDynamicNodes(GceInstancesService gceInstancesService, Settings nodeSettings) { GceUnicastHostsProvider provider = new GceUnicastHostsProvider(nodeSettings, gceInstancesService, transportService, new NetworkService(Settings.EMPTY));",
    "conflict": "protected List<DiscoveryNode> buildDynamicNodes(GceInstancesService gceInstancesService, Settings nodeSettings) { GceUnicastHostsProvider provider = new GceUnicastHostsProvider(nodeSettings, gceInstancesService, transportService, new NetworkService(Settings.EMPTY), Version.CURRENT);"
  },
  {
    "devdecision": "Manual",
    "id": 75698,
    "v2": "",
    "resolution": "import org.elasticsearch.cluster.service.ClusterService; import org.elasticsearch.env.Environment; import org.elasticsearch.ingest.Processor; import org.elasticsearch.ingest.TemplateService;",
    "conflict": "import org.elasticsearch.ExceptionsHelper; import org.elasticsearch.cluster.service.ClusterService; import org.elasticsearch.env.Environment; import org.elasticsearch.ingest.Processor; import org.elasticsearch.ingest.TemplateService;"
  },
  {
    "devdecision": "Manual",
    "id": 75705,
    "v2": "b.bind(ScriptService.class).toInstance(scriptModule.getScriptService()); }, settingsModule, new IndicesModule(namedWriteableRegistry) {",
    "resolution": "b.bind(ScriptService.class).toInstance(scriptModule.getScriptService()); }, settingsModule, new IndicesModule(namedWriteableRegistry, Collections.emptyList()) {",
    "conflict": "}, settingsModule, scriptModule, new IndicesModule(namedWriteableRegistry, Collections.emptyList()) {"
  },
  {
    "devdecision": "Combination",
    "id": 75720,
    "v2": "import static org.elasticsearch.xpack.security.authc.support.UsernamePasswordToken.basicAuthHeaderValue;",
    "resolution": "import java.io.IOException;  import static java.util.Collections.emptyList; import static java.util.Collections.emptyMap;  import static org.elasticsearch.xpack.security.authc.support.UsernamePasswordToken.basicAuthHeaderValue;",
    "conflict": "import java.io.IOException;  import static java.util.Collections.emptyList; import static java.util.Collections.emptyMap; import static org.elasticsearch.shield.authc.support.UsernamePasswordToken.basicAuthHeaderValue;"
  },
  {
    "devdecision": "Version 2",
    "id": 75730,
    "v2": "import org.elasticsearch.xpack.security.transport.SecurityServerTransportService; import org.elasticsearch.xpack.security.transport.netty.SecurityNettyTransport; import org.elasticsearch.test.SecurityIntegTestCase;",
    "resolution": "import org.elasticsearch.xpack.security.transport.SecurityServerTransportService; import org.elasticsearch.xpack.security.transport.netty.SecurityNettyTransport; import org.elasticsearch.test.SecurityIntegTestCase;",
    "conflict": "import org.elasticsearch.shield.transport.ShieldServerTransportService; import org.elasticsearch.shield.transport.netty.ShieldNettyTransport; import org.elasticsearch.test.ShieldIntegTestCase;"
  },
  {
    "devdecision": "Combination",
    "id": 75751,
    "v2": "import org.elasticsearch.http.HttpServerTransport; import org.elasticsearch.xpack.security.authc.support.SecuredString; import org.elasticsearch.test.rest.client.http.HttpRequestBuilder; import org.elasticsearch.test.rest.client.http.HttpResponse;",
    "resolution": "import org.elasticsearch.marvel.test.MarvelIntegTestCase; import org.elasticsearch.xpack.security.authc.support.SecuredString;",
    "conflict": "import org.elasticsearch.marvel.test.MarvelIntegTestCase; import org.elasticsearch.shield.authc.support.SecuredString;"
  },
  {
    "devdecision": "Combination",
    "id": 75752,
    "v2": "import static org.elasticsearch.xpack.security.authc.support.UsernamePasswordToken.BASIC_AUTH_HEADER; import static org.elasticsearch.xpack.security.authc.support.UsernamePasswordToken.basicAuthHeaderValue; import static org.elasticsearch.xpack.watcher.test.AbstractWatcherIntegrationTestCase.SecuritySettings.TEST_PASSWORD; import static org.elasticsearch.xpack.watcher.test.AbstractWatcherIntegrationTestCase.SecuritySettings.TEST_USERNAME;",
    "resolution": "import static org.elasticsearch.xpack.security.authc.support.UsernamePasswordToken.BASIC_AUTH_HEADER; import static org.elasticsearch.xpack.security.authc.support.UsernamePasswordToken.basicAuthHeaderValue;",
    "conflict": "import static org.elasticsearch.shield.authc.support.UsernamePasswordToken.BASIC_AUTH_HEADER; import static org.elasticsearch.shield.authc.support.UsernamePasswordToken.basicAuthHeaderValue;"
  },
  {
    "devdecision": "Manual",
    "id": 75756,
    "v2": "this.name = Objects.requireNonNull(name); this.source = Objects.requireNonNull(source);",
    "resolution": "this.settings = Objects.requireNonNull(settings); this.name = Objects.requireNonNull(name); this.source = Objects.requireNonNull(source);",
    "conflict": "this.settings = settings; this.name = name; this.source = source;"
  },
  {
    "devdecision": "Combination",
    "id": 75769,
    "v2": "new EnvironmentModule(new Environment(settings), threadPool), settingsModule, scriptModule, new IndicesModule() {",
    "resolution": "new EnvironmentModule(new Environment(settings), threadPool), settingsModule, scriptModule, new IndicesModule(namedWriteableRegistry) { @Override",
    "conflict": "new EnvironmentModule(new Environment(settings)), settingsModule, new ThreadPoolModule(threadPool), scriptModule, new IndicesModule(namedWriteableRegistry) {"
  },
  {
    "devdecision": "Manual",
    "id": 75812,
    "v2": "setState(220); chain(true); setState(221);",
    "resolution": "setState(224); chain(true); setState(225);",
    "conflict": "setState(193); chain(true); setState(194);"
  },
  {
    "devdecision": "Manual",
    "id": 75815,
    "v2": "setState(289); _errHandler.sync(this); _alt = getInterpreter().adaptivePredict(_input,20,_ctx);",
    "resolution": "setState(293); _errHandler.sync(this); _alt = getInterpreter().adaptivePredict(_input,21,_ctx);",
    "conflict": "setState(262); _errHandler.sync(this); _alt = getInterpreter().adaptivePredict(_input,18,_ctx);"
  },
  {
    "devdecision": "Manual",
    "id": 75817,
    "v2": "setState(230); if (!(precpred(_ctx, 12))) throw new FailedPredicateException(this, \"precpred(_ctx, 12)\"); setState(231);",
    "resolution": "setState(234); if (!(precpred(_ctx, 12))) throw new FailedPredicateException(this, \"precpred(_ctx, 12)\"); setState(235);",
    "conflict": "setState(203); if (!(precpred(_ctx, 12))) throw new FailedPredicateException(this, \"precpred(_ctx, 12)\"); setState(204);"
  },
  {
    "devdecision": "Manual",
    "id": 75819,
    "v2": "setState(235); if (!(precpred(_ctx, 11))) throw new FailedPredicateException(this, \"precpred(_ctx, 11)\"); setState(236);",
    "resolution": "setState(239); if (!(precpred(_ctx, 11))) throw new FailedPredicateException(this, \"precpred(_ctx, 11)\"); setState(240);",
    "conflict": "setState(208); if (!(precpred(_ctx, 11))) throw new FailedPredicateException(this, \"precpred(_ctx, 11)\"); setState(209);"
  },
  {
    "devdecision": "Manual",
    "id": 75821,
    "v2": "setState(240); if (!(precpred(_ctx, 10))) throw new FailedPredicateException(this, \"precpred(_ctx, 10)\"); setState(241);",
    "resolution": "setState(244); if (!(precpred(_ctx, 10))) throw new FailedPredicateException(this, \"precpred(_ctx, 10)\"); setState(245);",
    "conflict": "setState(213); if (!(precpred(_ctx, 10))) throw new FailedPredicateException(this, \"precpred(_ctx, 10)\"); setState(214);"
  },
  {
    "devdecision": "Manual",
    "id": 75823,
    "v2": "setState(245); if (!(precpred(_ctx, 9))) throw new FailedPredicateException(this, \"precpred(_ctx, 9)\"); setState(246);",
    "resolution": "setState(249); if (!(precpred(_ctx, 9))) throw new FailedPredicateException(this, \"precpred(_ctx, 9)\"); setState(250);",
    "conflict": "setState(218); if (!(precpred(_ctx, 9))) throw new FailedPredicateException(this, \"precpred(_ctx, 9)\"); setState(219);"
  },
  {
    "devdecision": "Manual",
    "id": 75825,
    "v2": "setState(250); if (!(precpred(_ctx, 8))) throw new FailedPredicateException(this, \"precpred(_ctx, 8)\"); setState(251);",
    "resolution": "setState(254); if (!(precpred(_ctx, 8))) throw new FailedPredicateException(this, \"precpred(_ctx, 8)\"); setState(255);",
    "conflict": "setState(223); if (!(precpred(_ctx, 8))) throw new FailedPredicateException(this, \"precpred(_ctx, 8)\"); setState(224);"
  },
  {
    "devdecision": "Manual",
    "id": 75833,
    "v2": "setState(291); _errHandler.sync(this); _alt = getInterpreter().adaptivePredict(_input,20,_ctx);",
    "resolution": "setState(295); _errHandler.sync(this); _alt = getInterpreter().adaptivePredict(_input,21,_ctx);",
    "conflict": "setState(264); _errHandler.sync(this); _alt = getInterpreter().adaptivePredict(_input,18,_ctx);"
  },
  {
    "devdecision": "Manual",
    "id": 75835,
    "v2": "setState(292); if (!( !_localctx.c )) throw new FailedPredicateException(this, \" !$c \"); setState(293);",
    "resolution": "setState(296); if (!( !_localctx.c )) throw new FailedPredicateException(this, \" !$c \"); setState(297);",
    "conflict": "setState(265); if (!( !_localctx.c )) throw new FailedPredicateException(this, \" !$c \"); setState(266);"
  },
  {
    "devdecision": "Manual",
    "id": 75838,
    "v2": "setState(299); if (!( !_localctx.c )) throw new FailedPredicateException(this, \" !$c \"); setState(300);",
    "resolution": "setState(303); if (!( !_localctx.c )) throw new FailedPredicateException(this, \" !$c \"); setState(304);",
    "conflict": "setState(272); if (!( !_localctx.c )) throw new FailedPredicateException(this, \" !$c \"); setState(273);"
  },
  {
    "devdecision": "Manual",
    "id": 75839,
    "v2": "setState(301); if (!( !_localctx.c )) throw new FailedPredicateException(this, \" !$c \"); setState(302);",
    "resolution": "setState(305); if (!( !_localctx.c )) throw new FailedPredicateException(this, \" !$c \"); setState(306);",
    "conflict": "setState(274); if (!( !_localctx.c )) throw new FailedPredicateException(this, \" !$c \"); setState(275);"
  },
  {
    "devdecision": "Manual",
    "id": 75840,
    "v2": "setState(304); if (!( !_localctx.c )) throw new FailedPredicateException(this, \" !$c \"); setState(305);",
    "resolution": "setState(308); if (!( !_localctx.c )) throw new FailedPredicateException(this, \" !$c \"); setState(309);",
    "conflict": "setState(277); if (!( !_localctx.c )) throw new FailedPredicateException(this, \" !$c \"); setState(278);"
  },
  {
    "devdecision": "Manual",
    "id": 75841,
    "v2": "setState(307); if (!( !_localctx.c )) throw new FailedPredicateException(this, \" !$c \"); setState(308);",
    "resolution": "setState(311); if (!( !_localctx.c )) throw new FailedPredicateException(this, \" !$c \"); setState(312);",
    "conflict": "setState(280); if (!( !_localctx.c )) throw new FailedPredicateException(this, \" !$c \"); setState(281);"
  },
  {
    "devdecision": "Manual",
    "id": 75842,
    "v2": "setState(310); if (!( !_localctx.c )) throw new FailedPredicateException(this, \" !$c \"); setState(311);",
    "resolution": "setState(314); if (!( !_localctx.c )) throw new FailedPredicateException(this, \" !$c \"); setState(315);",
    "conflict": "setState(283); if (!( !_localctx.c )) throw new FailedPredicateException(this, \" !$c \"); setState(284);"
  },
  {
    "devdecision": "Manual",
    "id": 75843,
    "v2": "setState(313); if (!( !_localctx.c )) throw new FailedPredicateException(this, \" !$c \"); setState(314);",
    "resolution": "setState(317); if (!( !_localctx.c )) throw new FailedPredicateException(this, \" !$c \"); setState(318);",
    "conflict": "setState(286); if (!( !_localctx.c )) throw new FailedPredicateException(this, \" !$c \"); setState(287);"
  },
  {
    "devdecision": "Manual",
    "id": 75849,
    "v2": "setState(329); _errHandler.sync(this); _alt = getInterpreter().adaptivePredict(_input,22,_ctx);",
    "resolution": "setState(333); _errHandler.sync(this); _alt = getInterpreter().adaptivePredict(_input,23,_ctx);",
    "conflict": "setState(302); _errHandler.sync(this); _alt = getInterpreter().adaptivePredict(_input,20,_ctx);"
  },
  {
    "devdecision": "Manual",
    "id": 75852,
    "v2": "setState(337); _errHandler.sync(this); _alt = getInterpreter().adaptivePredict(_input,23,_ctx);",
    "resolution": "setState(341); _errHandler.sync(this); _alt = getInterpreter().adaptivePredict(_input,24,_ctx);",
    "conflict": "setState(310); _errHandler.sync(this); _alt = getInterpreter().adaptivePredict(_input,21,_ctx);"
  },
  {
    "devdecision": "Manual",
    "id": 75857,
    "v2": "setState(354); _errHandler.sync(this); _alt = getInterpreter().adaptivePredict(_input,25,_ctx);",
    "resolution": "setState(358); _errHandler.sync(this); _alt = getInterpreter().adaptivePredict(_input,26,_ctx);",
    "conflict": "setState(327); _errHandler.sync(this); _alt = getInterpreter().adaptivePredict(_input,23,_ctx);"
  },
  {
    "devdecision": "Manual",
    "id": 75865,
    "v2": "setState(381); if (!( _localctx.s )) throw new FailedPredicateException(this, \" $s \"); setState(382);",
    "resolution": "setState(385); if (!( _localctx.s )) throw new FailedPredicateException(this, \" $s \"); setState(386);",
    "conflict": "setState(352); if (!( _localctx.s )) throw new FailedPredicateException(this, \" $s \"); setState(353);"
  },
  {
    "devdecision": "Manual",
    "id": 75868,
    "v2": "setState(388); match(DOT); setState(389);",
    "resolution": "setState(392); match(DOT); setState(393);",
    "conflict": "setState(359); match(DOT); setState(360);"
  },
  {
    "devdecision": "Manual",
    "id": 75884,
    "v2": "DeleteResponse response = new DeleteResponse(indexShard.shardId(), request.type(), request.id(), delete.version(), delete.found()); return new WriteResult<>(response, delete.getTranslogLocation());",
    "resolution": "DeleteResponse response = new DeleteResponse(indexShard.shardId(), request.type(), request.id(), delete.seqNo(), delete.version(), delete.found()); return new WriteResult<>(response, delete.getTranslogLocation());",
    "conflict": "return new WriteResult<>( new DeleteResponse(indexShard.shardId(), request.type(), request.id(), delete.seqNo(), delete.version(), delete.found()), delete.getTranslogLocation());"
  },
  {
    "devdecision": "Concatenation",
    "id": 75945,
    "v2": "public DocsStats getDocStats() { final int numDocs = indexWriter.numDocs(); final int maxDoc = indexWriter.maxDoc(); return new DocsStats(numDocs, maxDoc-numDocs);",
    "resolution": "public DocsStats getDocStats() { final int numDocs = indexWriter.numDocs(); final int maxDoc = indexWriter.maxDoc(); return new DocsStats(numDocs, maxDoc-numDocs);public SequenceNumbersService seqNoService() { return seqNoService;",
    "conflict": "public SequenceNumbersService seqNoService() { return seqNoService;"
  },
  {
    "devdecision": "Version 2",
    "id": 75946,
    "v2": "",
    "resolution": "",
    "conflict": "// for tests Runnable getGlobalCheckpointSyncer() { return globalCheckpointSyncer; }"
  },
  {
    "devdecision": "Combination",
    "id": 75965,
    "v2": "import org.elasticsearch.common.util.concurrent.EsExecutors; import org.elasticsearch.common.util.concurrent.FutureUtils; import org.elasticsearch.xpack.support.clock.Clock;",
    "resolution": "import org.elasticsearch.xpack.scheduler.SchedulerEngine; import org.elasticsearch.xpack.support.clock.Clock;",
    "conflict": "import org.elasticsearch.xpack.scheduler.SchedulerEngine; import org.elasticsearch.xpack.watcher.support.clock.Clock;"
  },
  {
    "devdecision": "Manual",
    "id": 75971,
    "v2": "shardsStats.add(new ShardStats(indexShard.routingEntry(), indexShard.shardPath(), new CommonStats(indicesService.getIndicesQueryCache(), indexShard, SHARD_STATS_FLAGS), indexShard.commitStats()));",
    "resolution": "shardsStats.add( new ShardStats( indexShard.routingEntry(), indexShard.shardPath(), new CommonStats(indicesService.getIndicesQueryCache(), indexShard, SHARD_STATS_FLAGS), indexShard.commitStats(), indexShard.seqNoStats()));",
    "conflict": "shardsStats.add(new ShardStats(indexShard.routingEntry(), indexShard.shardPath(), new CommonStats(indicesService.getIndicesQueryCache(), indexService.cache().getPercolatorQueryCache(), indexShard, SHARD_STATS_FLAGS), indexShard.commitStats(), indexShard.seqNoStats()));"
  },
  {
    "devdecision": "Manual",
    "id": 75974,
    "v2": "ShardStats stats = new ShardStats(shard.routingEntry(), shard.shardPath(), new CommonStats(indicesService.getIndicesQueryCache(), shard, new CommonStatsFlags()), shard.commitStats());",
    "resolution": "ShardStats stats = new ShardStats( shard.routingEntry(), shard.shardPath(), new CommonStats(indicesService.getIndicesQueryCache(), shard, new CommonStatsFlags()), shard.commitStats(), shard.seqNoStats());",
    "conflict": "ShardStats stats = new ShardStats(shard.routingEntry(), shard.shardPath(), new CommonStats(indicesService.getIndicesQueryCache(), test.cache().getPercolatorQueryCache(), shard, new CommonStatsFlags()), shard.commitStats(), shard.seqNoStats());"
  },
  {
    "devdecision": "Version 1",
    "id": 75975,
    "v2": "\"  \\\"operations\\\" : 6,\\n\" + \"  \\\"size_in_bytes\\\" : 431\\n\" + \"}\", copy.toString().trim());",
    "resolution": "\"  \\\"operations\\\" : 6,\\n\" + \"  \\\"size_in_bytes\\\" : 437\\n\" + \"}\", copy.toString().trim());",
    "conflict": "\"  \\\"operations\\\" : 6,\\n\" + \"  \\\"size_in_bytes\\\" : 437\\n\" + \"}\", copy.toString().trim());"
  },
  {
    "devdecision": "Manual",
    "id": 75978,
    "v2": "public static Cast getLegalCast(final Definition definition, final String location, final Type actual, final Type expected, final boolean explicit, final boolean internal) {",
    "resolution": "public static Cast getLegalCast(String location, Type actual, Type expected, boolean explicit, boolean internal) {",
    "conflict": "public static Cast getLegalCast(final String location, final Type actual, final Type expected, final boolean explicit) { final Cast cast = new Cast(actual, expected, explicit);"
  },
  {
    "devdecision": "Manual",
    "id": 76021,
    "v2": "} else if (!left.isNull && (operation == Operation.EQ || operation == Operation.NE)) { adapter.invokeStatic(DEF_TYPE, DEF_EQ_CALL); writejump = false;",
    "resolution": "} else if (!left.isNull && (operation == Operation.EQ || operation == Operation.NE)) { adapter.invokeStatic(DEF_UTIL_TYPE, DEF_EQ_CALL); writejump = false;",
    "conflict": "} else if (!left.isNull && operation == Operation.EQ) { adapter.invokeStatic(Definition.DEF_UTIL_TYPE.type, DEF_EQ_CALL);"
  },
  {
    "devdecision": "Combination",
    "id": 76031,
    "v2": "expression.internal = true; expression.analyze(settings, definition, variables); arguments.set(argument, expression.cast(settings, definition, variables));",
    "resolution": "expression.internal = true; expression.analyze(variables); arguments.set(argument, expression.cast(variables));",
    "conflict": "expression.analyze(variables); arguments.set(argument, expression.cast(variables));"
  },
  {
    "devdecision": "Combination",
    "id": 76034,
    "v2": "expression.internal = true; expression.analyze(settings, definition, variables); arguments.set(argument, expression.cast(settings, definition, variables));",
    "resolution": "expression.internal = true; expression.analyze(variables); arguments.set(argument, expression.cast(variables));",
    "conflict": "expression.analyze(variables); arguments.set(argument, expression.cast(variables));"
  },
  {
    "devdecision": "Combination",
    "id": 76035,
    "v2": "expression.expected = rtn ? definition.getType(\"Object\") : expression.actual; expression.internal = rtn; expression = expression.cast(settings, definition, variables);",
    "resolution": "expression.expected = rtn ? Definition.OBJECT_TYPE : expression.actual; expression.internal = rtn; expression = expression.cast(variables);",
    "conflict": "expression.expected = rtn ? Definition.OBJECT_TYPE : expression.actual; expression = expression.cast(variables);"
  },
  {
    "devdecision": "Combination",
    "id": 76050,
    "v2": "context.sourceToParse().id(), context.sourceToParse().type(),",
    "resolution": "context.seqNo(), context.sourceToParse().id(), context.sourceToParse().type(),",
    "conflict": "context.seqNo(), context.id(), context.type(),"
  },
  {
    "devdecision": "Manual",
    "id": 76055,
    "v2": "MappedFieldType uidFieldType = docMapper.getDocumentMapper().uidMapper().fieldType(); Query uidQuery = uidFieldType.termQuery(doc.uid(), null); Term uid = MappedFieldType.extractTerm(uidQuery); return new Engine.Index(uid, doc, version, versionType, origin, startTime);",
    "resolution": "MappedFieldType uidFieldType = docMapper.getDocumentMapper().uidMapper().fieldType(); Query uidQuery = uidFieldType.termQuery(doc.uid(), null); Term uid = MappedFieldType.extractTerm(uidQuery); doc.seqNo().setLongValue(seqNo); return new Engine.Index(uid, doc, seqNo, version, versionType, origin, startTime);",
    "conflict": "doc.seqNo().setLongValue(seqNo); return new Engine.Index(docMapper.getDocumentMapper().uidMapper().term(doc.uid().stringValue()), doc, seqNo, version, versionType, origin, startTime);"
  },
  {
    "devdecision": "Combination",
    "id": 76056,
    "v2": "final MappedFieldType uidFieldType = documentMapper.uidMapper().fieldType(); final Query uidQuery = uidFieldType.termQuery(Uid.createUid(type, id), null); final Term uid = MappedFieldType.extractTerm(uidQuery); return prepareDelete(type, id, uid, version, versionType, Engine.Operation.Origin.PRIMARY);",
    "resolution": "final MappedFieldType uidFieldType = documentMapper.uidMapper().fieldType(); final Query uidQuery = uidFieldType.termQuery(Uid.createUid(type, id), null); final Term uid = MappedFieldType.extractTerm(uidQuery); return prepareDelete(type, id, uid, SequenceNumbersService.UNASSIGNED_SEQ_NO, version, versionType, Engine.Operation.Origin.PRIMARY);",
    "conflict": "final Term uid = documentMapper.uidMapper().term(Uid.createUid(type, id)); return prepareDelete(type, id, uid, SequenceNumbersService.UNASSIGNED_SEQ_NO, version, versionType, Engine.Operation.Origin.PRIMARY);"
  },
  {
    "devdecision": "Combination",
    "id": 76057,
    "v2": "final MappedFieldType uidFieldType = documentMapper.uidMapper().fieldType(); final Query uidQuery = uidFieldType.termQuery(Uid.createUid(type, id), null); final Term uid = MappedFieldType.extractTerm(uidQuery); return prepareDelete(type, id, uid, version, versionType, Engine.Operation.Origin.REPLICA);",
    "resolution": "final MappedFieldType uidFieldType = documentMapper.uidMapper().fieldType(); final Query uidQuery = uidFieldType.termQuery(Uid.createUid(type, id), null); final Term uid = MappedFieldType.extractTerm(uidQuery); return prepareDelete(type, id, uid, seqNo, version, versionType, Engine.Operation.Origin.REPLICA);",
    "conflict": "final Term uid = documentMapper.uidMapper().term(Uid.createUid(type, id)); return prepareDelete(type, id, uid, seqNo, version, versionType, Engine.Operation.Origin.REPLICA);"
  },
  {
    "devdecision": "Manual",
    "id": 76059,
    "v2": "final Engine.Delete engineDelete = new Engine.Delete(uid.type(), uid.id(), delete.uid(), delete.version(), delete.versionType().versionTypeForReplicationAndRecovery(), Engine.Operation.Origin.RECOVERY, System.nanoTime(), false); delete(engine, engineDelete);",
    "resolution": "final Engine.Delete engineDelete = IndexShard.prepareDelete(uid.type(), uid.id(), delete.uid(), delete.seqNo(), delete.version(), delete.versionType().versionTypeForReplicationAndRecovery(), Engine.Operation.Origin.RECOVERY); delete(engine, engineDelete);",
    "conflict": "Engine.Delete engineDelete = IndexShard.prepareDelete(uid.type(), uid.id(), delete.uid(), delete.seqNo(), delete.version(), delete.versionType().versionTypeForReplicationAndRecovery(), Engine.Operation.Origin.RECOVERY); engine.delete(engineDelete);"
  },
  {
    "devdecision": "Manual",
    "id": 76071,
    "v2": ".setSettings(Settings.builder() .put(\"index.number_of_shards\", 1) .put(\"index.number_of_replicas\", 0)",
    "resolution": ".setSettings(Settings.builder() .put(\"index.number_of_shards\", 1) .put(\"index.number_of_replicas\", 0))",
    "conflict": ".setSettings(Settings.settingsBuilder() .put(\"index.number_of_shards\", 1) .put(\"index.number_of_replicas\", 0)"
  },
  {
    "devdecision": "Manual",
    "id": 76072,
    "v2": ".setSettings(Settings.builder() .put(\"index.number_of_shards\", 1) .put(\"index.number_of_replicas\", numberOfReplicas)",
    "resolution": ".setSettings(Settings.builder() .put(\"index.number_of_shards\", 1) .put(\"index.number_of_replicas\", numberOfReplicas)).execute().actionGet();",
    "conflict": ".setSettings(settingsBuilder() .put(\"index.number_of_shards\", 1) .put(\"index.number_of_replicas\", numberOfReplicas)"
  },
  {
    "devdecision": "Manual",
    "id": 76075,
    "v2": "private synchronized AmazonS3 getClient(String endpoint, Protocol protocol, String account, String key, Integer maxRetries) { Tuple<String, String> clientDescriptor = new Tuple<>(endpoint, account);",
    "resolution": "private synchronized AmazonS3 getClient(String endpoint, Protocol protocol, String account, String key, Integer maxRetries, Boolean pathStyleAccess) { Tuple<String, String> clientDescriptor = new Tuple<>(endpoint, account);",
    "conflict": "private synchronized AmazonS3 getClient(String endpoint, String protocol, String account, String key, Integer maxRetries, Boolean pathStyleAccess) { Tuple<String, String> clientDescriptor = new Tuple<String, String>(endpoint, account);"
  },
  {
    "devdecision": "Combination",
    "id": 76077,
    "v2": "String storageClass = getValue(repositorySettings, Repository.STORAGE_CLASS_SETTING, Repositories.STORAGE_CLASS_SETTING); String cannedACL = getValue(repositorySettings, Repository.CANNED_ACL_SETTING, Repositories.CANNED_ACL_SETTING);",
    "resolution": "String storageClass = getValue(repositorySettings, Repository.STORAGE_CLASS_SETTING, Repositories.STORAGE_CLASS_SETTING); String cannedACL = getValue(repositorySettings, Repository.CANNED_ACL_SETTING, Repositories.CANNED_ACL_SETTING); Boolean pathStyleAccess = repositorySettings.settings().getAsBoolean(\"path_style_access\", settings.getAsBoolean(REPOSITORY_S3.PATH_STYLE_ACCESS, null));",
    "conflict": "String storageClass = repositorySettings.settings().get(\"storage_class\", settings.get(REPOSITORY_S3.STORAGE_CLASS, null)); String cannedACL = repositorySettings.settings().get(\"canned_acl\", settings.get(REPOSITORY_S3.CANNED_ACL, null)); Boolean pathStyleAccess = repositorySettings.settings().getAsBoolean(\"path_style_access\", settings.getAsBoolean(REPOSITORY_S3.PATH_STYLE_ACCESS, null));"
  },
  {
    "devdecision": "Version 2",
    "id": 76085,
    "v2": "MockTransportService masterTransportService = (MockTransportService) internalCluster().getInstance(TransportService.class, masterNode); TransportService localTransportService = internalCluster().getInstance(TransportService.class, discoveryNodes.getLocalNode().getName());",
    "resolution": "MockTransportService masterTransportService = (MockTransportService) internalCluster().getInstance(TransportService.class, masterNode); TransportService localTransportService = internalCluster().getInstance(TransportService.class, discoveryNodes.getLocalNode().getName());",
    "conflict": "MockTransportService masterTransportService = (MockTransportService) internalCluster().getInstance(TransportService.class, masterNode); TransportService localTransportService = internalCluster().getInstance(TransportService.class, discoveryNodes.localNode().getName());"
  },
  {
    "devdecision": "Version 1",
    "id": 76093,
    "v2": "",
    "resolution": "import org.elasticsearch.common.ParseFieldMatcher; import org.elasticsearch.common.ParsingException; import org.elasticsearch.common.settings.Settings; import org.elasticsearch.common.xcontent.XContentFactory; import org.elasticsearch.common.xcontent.XContentParser;",
    "conflict": "import org.elasticsearch.common.ParseFieldMatcher; import org.elasticsearch.common.ParsingException; import org.elasticsearch.common.settings.Settings; import org.elasticsearch.common.xcontent.XContentFactory; import org.elasticsearch.common.xcontent.XContentParser;"
  },
  {
    "devdecision": "Version 2",
    "id": 76119,
    "v2": "* Called once a new Searcher is opened on the top-level searcher.",
    "resolution": "* Called once a new Searcher is opened on the top-level searcher.",
    "conflict": "* Called once a new Searcher is opened. * * @param searcher         the searcer to warm * @param isTopLevelReader <code>true</code> iff the searcher is build from a top-level reader. *                         Otherwise the searcher might be build from a leaf reader to warm in isolation"
  },
  {
    "devdecision": "Combination",
    "id": 76121,
    "v2": "verifyPrimary(); return prepareIndex(docMapper(source.type()), source, version, versionType, Engine.Operation.Origin.PRIMARY);",
    "resolution": "verifyPrimary(); return prepareIndex(docMapper(source.type()), source, SequenceNumbersService.UNASSIGNED_SEQ_NO, version, versionType, Engine.Operation.Origin.PRIMARY);",
    "conflict": "if (shardRouting.primary() == false) { throw new IllegalIndexShardStateException(shardId, state, \"shard is not a primary\"); } return prepareIndex(docMapper(source.type()), source, SequenceNumbersService.UNASSIGNED_SEQ_NO, version, versionType, Engine.Operation.Origin.PRIMARY);"
  },
  {
    "devdecision": "Combination",
    "id": 76122,
    "v2": "verifyReplicationTarget(); return prepareIndex(docMapper(source.type()), source, version, versionType, Engine.Operation.Origin.REPLICA);",
    "resolution": "verifyReplicationTarget(); return prepareIndex(docMapper(source.type()), source, seqNo, version, versionType, Engine.Operation.Origin.REPLICA);",
    "conflict": "if (shardRouting.primary() && shardRouting.isRelocationTarget() == false) { throw new IllegalIndexShardStateException(shardId, state, \"shard is not a replica\"); } return prepareIndex(docMapper(source.type()), source, seqNo, version, versionType, Engine.Operation.Origin.REPLICA);"
  },
  {
    "devdecision": "Version 2",
    "id": 76125,
    "v2": "indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(0).id(), null, null, true, ShardRoutingState.STARTED, null)); indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(1).id(), null, null, false,",
    "resolution": "indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(0).id(), null, null, true, ShardRoutingState.STARTED, null)); indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(1).id(), null, null, false,",
    "conflict": "indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(0).id(), null, null, primaryTerm, true, ShardRoutingState.STARTED, null)); indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(1).id(), null, null, primaryTerm, false,"
  },
  {
    "devdecision": "Version 2",
    "id": 76150,
    "v2": "",
    "resolution": "",
    "conflict": "if (state != IndexShardState.CLOSED) { FutureUtils.cancel(refreshScheduledFuture); refreshScheduledFuture = null; } // nocommit: done to temporary prevent operations on a relocated primary. Remove when properly fixed. final boolean decOpCounter = state != IndexShardState.RELOCATED;"
  },
  {
    "devdecision": "Manual",
    "id": 76151,
    "v2": "IndexShardStats indexShardStats = new IndexShardStats(indexShard.shardId(), new ShardStats[] { new ShardStats(indexShard.routingEntry(), indexShard.shardPath(), new CommonStats(indicesQueryCache, indexService.cache().getPercolatorQueryCache(), indexShard, flags), indexShard.commitStats()) });",
    "resolution": "IndexShardStats indexShardStats = new IndexShardStats(indexShard.shardId(), new ShardStats[] { new ShardStats(indexShard.routingEntry(), indexShard.shardPath(), new CommonStats(indicesQueryCache, indexService.cache().getPercolatorQueryCache(), indexShard, flags), indexShard.commitStats(), indexShard.seqNoStats())});",
    "conflict": "IndexShardStats indexShardStats = new IndexShardStats(indexShard.shardId(), new ShardStats[] { new ShardStats(indexShard.routingEntry(), indexShard.shardPath(), new CommonStats(indicesQueryCache, indexShard, flags), indexShard.commitStats(), indexShard.seqNoStats()) });"
  },
  {
    "devdecision": "Version 2",
    "id": 76162,
    "v2": "public static final Setting<TimeValue> CLUSTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING = Setting.positiveTimeSetting(\"cluster.service.slow_task_logging_threshold\", TimeValue.timeValueSeconds(30), Property.Dynamic, Property.NodeScope);",
    "resolution": "public static final Setting<TimeValue> CLUSTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING = Setting.positiveTimeSetting(\"cluster.service.slow_task_logging_threshold\", TimeValue.timeValueSeconds(30), Property.Dynamic, Property.NodeScope);",
    "conflict": "public static final Setting<TimeValue> CLUSTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING = Setting.positiveTimeSetting(\"cluster.service.slow_task_logging_threshold\", TimeValue.timeValueSeconds(30), true, Setting.Scope.CLUSTER); public static final Setting<TimeValue> CLUSTER_SERVICE_RECONNECT_INTERVAL_SETTING = Setting.positiveTimeSetting(\"cluster.service.reconnect_interval\", TimeValue.timeValueSeconds(10), false, Setting.Scope.CLUSTER);"
  },
  {
    "devdecision": "Version 2",
    "id": 76164,
    "v2": "public void writeOptionalWriteable(@Nullable Writeable writeable) throws IOException {",
    "resolution": "public void writeOptionalWriteable(@Nullable Writeable writeable) throws IOException {",
    "conflict": "/** * Serializes a potential null value. */ public void writeOptionalWritable(@Nullable Writeable writeable) throws IOException {"
  },
  {
    "devdecision": "Manual",
    "id": 76166,
    "v2": "ShardStats[] stats  = new ShardStats[] { new ShardStats(test_0, new ShardPath(false, test0Path, test0Path, test_0.shardId()), commonStats0 , null), new ShardStats(test_1, new ShardPath(false, test1Path, test1Path, test_1.shardId()), commonStats1 , null)",
    "resolution": "ShardStats[] stats  = new ShardStats[] { new ShardStats(test_0, new ShardPath(false, test0Path, test0Path, test_0.shardId()), commonStats0 , null, null), new ShardStats(test_1, new ShardPath(false, test1Path, test1Path, test_1.shardId()), commonStats1 , null, null)",
    "conflict": "ShardStats[] stats = new ShardStats[]{ new ShardStats(test_0, new ShardPath(false, test0Path, test0Path, \"0xdeadbeef\", test_0.shardId()), commonStats0, null, null), new ShardStats(test_1, new ShardPath(false, test1Path, test1Path, \"0xdeadbeef\", test_1.shardId()), commonStats1, null, null)"
  },
  {
    "devdecision": "Manual",
    "id": 76167,
    "v2": "return TestShardRouting.newShardRouting(shardRouting.index(), shardRouting.id(), DiscoveryNodeService.generateNodeId(Settings.EMPTY), randomBoolean(), randomFrom(ShardRoutingState.values()));",
    "resolution": "return TestShardRouting.newShardRouting(shardRouting.index(), shardRouting.id(), DiscoveryNodeService.generateNodeId(Settings.EMPTY), randomInt(20), randomBoolean(), randomFrom(ShardRoutingState.values()));",
    "conflict": "return TestShardRouting.newShardRouting(shardRouting.index(), shardRouting.id(), InternalClusterService.generateNodeId(Settings.EMPTY), randomInt(20), randomBoolean(), randomFrom(ShardRoutingState.values()));"
  },
  {
    "devdecision": "Version 2",
    "id": 76168,
    "v2": "ClusterService cs = getInstanceFromNode(ClusterService.class); final Index index = cs.state().metaData().index(\"test\").getIndex(); Path[] shardPaths = env.availableShardPaths(new ShardId(index, 0)); logger.info(\"--> paths: [{}]\", (Object)shardPaths);",
    "resolution": "ClusterService cs = getInstanceFromNode(ClusterService.class); final Index index = cs.state().metaData().index(\"test\").getIndex(); Path[] shardPaths = env.availableShardPaths(new ShardId(index, 0)); logger.info(\"--> paths: [{}]\", (Object)shardPaths);",
    "conflict": "Path[] shardPaths = env.availableShardPaths(new ShardId(\"test\", \"_na_\", 0)); logger.info(\"--> paths: [{}]\", (Object) shardPaths);"
  },
  {
    "devdecision": "Version 2",
    "id": 76194,
    "v2": "IndexService indexServiceOrNull = indicesService.indexService(shardId.getIndex()); if (indexServiceOrNull !=  null) { IndexShard shard = indexService.getShardOrNull(shardId.getId());",
    "resolution": "IndexService indexServiceOrNull = indicesService.indexService(shardId.getIndex()); if (indexServiceOrNull !=  null) { IndexShard shard = indexService.getShardOrNull(shardId.getId());",
    "conflict": "IndexService indexServiceOrNull = indicesService.indexService(request.concreteIndex()); if (indexServiceOrNull != null) { IndexShard shard = indexService.getShardOrNull(request.shardId());"
  },
  {
    "devdecision": "Version 2",
    "id": 76198,
    "v2": ".put(IndexMetaData.builder(shardId.getIndexName()).settings(settings(version)).numberOfShards(1).numberOfReplicas(0) .putActiveAllocationIds(0, hasActiveAllocation ? Sets.newHashSet(\"allocId\") : Collections.emptySet())) .build();",
    "resolution": ".put(IndexMetaData.builder(shardId.getIndexName()).settings(settings(version)).numberOfShards(1).numberOfReplicas(0) .putActiveAllocationIds(0, hasActiveAllocation ? Sets.newHashSet(\"allocId\") : Collections.emptySet())) .build();",
    "conflict": ".put(IndexMetaData.builder(shardId.getIndexName()).settings(settings(version)).numberOfShards(1).numberOfReplicas(0) .putActiveAllocationIds(0, version == Version.CURRENT ? Sets.newHashSet(\"allocId\") : Collections.emptySet())) .build();"
  },
  {
    "devdecision": "Combination",
    "id": 76211,
    "v2": "import org.elasticsearch.common.cli.MockTerminal; import org.elasticsearch.common.cli.UserError; import org.elasticsearch.common.settings.Settings; import org.elasticsearch.env.Environment;",
    "resolution": "import org.elasticsearch.common.cli.MockTerminal; import org.elasticsearch.common.cli.Terminal;",
    "conflict": "import org.elasticsearch.common.cli.Terminal;"
  },
  {
    "devdecision": "Version 2",
    "id": 76219,
    "v2": "",
    "resolution": "",
    "conflict": "}  @Override public void doPrint(String msg) { console.printf(\"%s\", msg); console.flush();"
  },
  {
    "devdecision": "Combination",
    "id": 76234,
    "v2": "builder.field(\"key\", key.toString()); builder.field(\"type\", scope.name()); builder.field(\"dynamic\", dynamic);",
    "resolution": "builder.field(\"key\", key.toString()); builder.field(\"properties\", properties);",
    "conflict": "builder.field(\"key\", key); builder.field(\"properties\", properties);"
  },
  {
    "devdecision": "Combination",
    "id": 76246,
    "v2": "termSuggestion(suggestField).field(suggestField).text(suggestText).size(suggestSize).suggestMode(suggestMode)));",
    "resolution": "termSuggestion(suggestField).field(suggestField) .text(suggestText).size(suggestSize) .suggestMode(SuggestMode.resolve(suggestMode))));",
    "conflict": "termSuggestion(suggestField).field(suggestField) .text(suggestText).size(suggestSize) .suggestMode(SuggestMode.resolve(suggestMode)))); modified = true;"
  },
  {
    "devdecision": "Combination",
    "id": 76253,
    "v2": "public SearchSourceBuilder fromXContent(XContentParser parser, QueryParseContext context, AggregatorParsers aggParsers) throws IOException {",
    "resolution": "/** * Create a new SearchSourceBuilder with attributes set by an xContent. */ public SearchSourceBuilder fromXContent(XContentParser parser, QueryParseContext context, AggregatorParsers aggParsers) throws IOException {",
    "conflict": "/** * Create a new SearchSourceBuilder with attributes set by an xContent. */ public SearchSourceBuilder fromXContent(XContentParser parser, QueryParseContext context) throws IOException {"
  },
  {
    "devdecision": "Version 2",
    "id": 76295,
    "v2": "*     Engine GC deletion if enabled collects deleted documents from in-memory realtime data structures after a certain amount of *     time ({@link IndexSettings#getGcDeletesInMillis()} if enabled. Before deletes are GCed they will cause re-adding the document that was deleted *     to fail.",
    "resolution": "*     Engine GC deletion if enabled collects deleted documents from in-memory realtime data structures after a certain amount of *     time ({@link IndexSettings#getGcDeletesInMillis()} if enabled. Before deletes are GCed they will cause re-adding the document that was deleted *     to fail.",
    "conflict": "* Engine GC deletion if enabled collects deleted documents from in-memory realtime data structures after a certain amount of * time ({@link #getGcDeletesInMillis()} if enabled. Before deletes are GCed they will cause re-adding the document that was deleted * to fail."
  },
  {
    "devdecision": "Concatenation",
    "id": 76296,
    "v2": "// How many callers are currently requesting index throttling.  Currently there are only two situations where we do this: when merges // are falling behind and when writing indexing buffer to disk is too slow.  When this is 0, there is no throttling, else we throttling // incoming indexing ops to a single thread: private final AtomicInteger throttleRequestCount = new AtomicInteger();",
    "resolution": "// How many callers are currently requesting index throttling.  Currently there are only two situations where we do this: when merges // are falling behind and when writing indexing buffer to disk is too slow.  When this is 0, there is no throttling, else we throttling // incoming indexing ops to a single thread: private final AtomicInteger throttleRequestCount = new AtomicInteger();private final SequenceNumbersService seqNoService;",
    "conflict": "private final SequenceNumbersService seqNoService;"
  },
  {
    "devdecision": "Manual",
    "id": 76312,
    "v2": "final ShardId shardId = new ShardId(index, \"_na_\", ++shardIndex); ShardRouting shard = TestShardRouting.newShardRouting(index, shardId.getId(), node.id(), true, ShardRoutingState.STARTED);",
    "resolution": "final ShardId shardId = new ShardId(index, \"_na_\", ++shardIndex); final int primaryTerm = randomInt(200); ShardRouting shard = TestShardRouting.newShardRouting(index, shardId.getId(), node.id(), primaryTerm, true, ShardRoutingState.STARTED);",
    "conflict": "final ShardId shardId = new ShardId(index, ++shardIndex); final int primaryTerm = randomInt(200); ShardRouting shard = TestShardRouting.newShardRouting(index, shardId.getId(), node.id(), primaryTerm, true, ShardRoutingState.STARTED, 1);"
  },
  {
    "devdecision": "Manual",
    "id": 76316,
    "v2": "indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(0).id(), null, null, true, ShardRoutingState.STARTED, null)); indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(1).id(), null, null, false, ShardRoutingState.STARTED, null));",
    "resolution": "indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(0).id(), null, null, primaryTerm, true, ShardRoutingState.STARTED, null)); indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(1).id(), null, null, primaryTerm, false, ShardRoutingState.STARTED, null));",
    "conflict": "indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(0).id(), null, null, primaryTerm, true, ShardRoutingState.STARTED, 0, null)); indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(1).id(), null, null, primaryTerm, false, ShardRoutingState.STARTED, 0, null));"
  },
  {
    "devdecision": "Version 2",
    "id": 76317,
    "v2": "Map<String, List<CapturingTransport.CapturedRequest>> capturedRequestsByTargetNode = transport.getCapturedRequestsByTargetNodeAndClear(); assertPhase(task, \"replicating\"); for (String node : new String[] {relocatingReplicaShard.currentNodeId(), relocatingReplicaShard.relocatingNodeId()}) { List<CapturingTransport.CapturedRequest> requests = capturedRequestsByTargetNode.get(node);",
    "resolution": "Map<String, List<CapturingTransport.CapturedRequest>> capturedRequestsByTargetNode = transport.getCapturedRequestsByTargetNodeAndClear(); assertPhase(task, \"replicating\"); for (String node : new String[] {relocatingReplicaShard.currentNodeId(), relocatingReplicaShard.relocatingNodeId()}) { List<CapturingTransport.CapturedRequest> requests = capturedRequestsByTargetNode.get(node);",
    "conflict": "for (String node : new String[]{relocatingReplicaShard.currentNodeId(), relocatingReplicaShard.relocatingNodeId()}) { List<CapturingTransport.CapturedRequest> requests = transport.capturedRequestsByTargetNode().get(node);"
  },
  {
    "devdecision": "Manual",
    "id": 76318,
    "v2": "TransportReplicationAction.IndexShardReference reference = getOrCreateIndexShardOperationsCounter();  ShardRouting primaryShard = state.getRoutingTable().shardRoutingTable(shardId).primaryShard(); indexShardRouting.set(primaryShard);",
    "resolution": "TransportReplicationAction.IndexShardReference reference = getOrCreateIndexShardOperationsCounter(0);  ShardRouting primaryShard = state.getRoutingTable().shardRoutingTable(shardId).primaryShard(); indexShardRouting.set(primaryShard);",
    "conflict": "Releasable reference = createIndexShardReference(0);"
  },
  {
    "devdecision": "Manual",
    "id": 76339,
    "v2": "otherRouting = TestShardRouting.newShardRouting(otherRouting.getIndexName(), otherRouting.id(), otherRouting.currentNodeId(), otherRouting.relocatingNodeId(), otherRouting.restoreSource(), otherRouting.primary(), newState, unassignedInfo);",
    "resolution": "otherRouting = TestShardRouting.newShardRouting(otherRouting.getIndexName(), otherRouting.id(), otherRouting.currentNodeId(), otherRouting.relocatingNodeId(), otherRouting.restoreSource(), otherRouting.primaryTerm(), otherRouting.primary(), newState, unassignedInfo);",
    "conflict": "otherRouting = TestShardRouting.newShardRouting(otherRouting.index(), otherRouting.id(), otherRouting.currentNodeId(), otherRouting.relocatingNodeId(), otherRouting.restoreSource(), otherRouting.primaryTerm(), otherRouting.primary(), newState, otherRouting.version(), unassignedInfo);"
  },
  {
    "devdecision": "Combination",
    "id": 76347,
    "v2": "TestShardRouting.newShardRouting(initShard.index(), initShard.id(), initShard.currentNodeId(), initShard.relocatingNodeId(), initShard.primary(), ShardRoutingState.INITIALIZING, initShard.allocationId())), false);",
    "resolution": "TestShardRouting.newShardRouting(initShard.index(), initShard.id(), initShard.currentNodeId(), initShard.relocatingNodeId(), initShard.primaryTerm(), initShard.primary(), ShardRoutingState.INITIALIZING, initShard.allocationId())), false);",
    "conflict": "TestShardRouting.newShardRouting(initShard.index(), initShard.id(), initShard.currentNodeId(), initShard.relocatingNodeId(), initShard.primaryTerm(), initShard.primary(), ShardRoutingState.INITIALIZING, initShard.allocationId(), randomInt())), false);"
  },
  {
    "devdecision": "Manual",
    "id": 76349,
    "v2": "TestShardRouting.newShardRouting(startedShard.index(), startedShard.id(), startedShard.currentNodeId(), startedShard.relocatingNodeId(), startedShard.primary(), ShardRoutingState.INITIALIZING, startedShard.allocationId())), false);",
    "resolution": "TestShardRouting.newShardRouting(startedShard.index(), startedShard.id(), startedShard.currentNodeId(), startedShard.relocatingNodeId(), startedShard.primaryTerm(), startedShard.primary(), ShardRoutingState.INITIALIZING, startedShard.allocationId())), false);",
    "conflict": "TestShardRouting.newShardRouting(startedShard.index(), startedShard.id(), startedShard.currentNodeId(), startedShard.relocatingNodeId(), startedShard.primaryTerm(), startedShard.primary(), ShardRoutingState.INITIALIZING, startedShard.allocationId(), 1)), false);"
  },
  {
    "devdecision": "Combination",
    "id": 76350,
    "v2": "TestShardRouting.newShardRouting(relocatingShard.index(), relocatingShard.id(), relocatingShard.relocatingNodeId(), relocatingShard.currentNodeId(), relocatingShard.primary(), ShardRoutingState.INITIALIZING, targetAllocationId)), false);",
    "resolution": "TestShardRouting.newShardRouting(relocatingShard.index(), relocatingShard.id(), relocatingShard.relocatingNodeId(), relocatingShard.currentNodeId(), relocatingShard.primaryTerm(), relocatingShard.primary(), ShardRoutingState.INITIALIZING, targetAllocationId)), false);",
    "conflict": "TestShardRouting.newShardRouting(relocatingShard.index(), relocatingShard.id(), relocatingShard.relocatingNodeId(), relocatingShard.currentNodeId(), relocatingShard.primaryTerm(), relocatingShard.primary(), ShardRoutingState.INITIALIZING, targetAllocationId, randomInt())), false);"
  },
  {
    "devdecision": "Manual",
    "id": 76367,
    "v2": "randomBoolean(), ShardRoutingState.UNASSIGNED, new UnassignedInfo(randomFrom(UnassignedInfo.Reason.values()), \"foobar\")), TestShardRouting.newShardRouting(\"newest\", 0, null, null, null, randomBoolean(), ShardRoutingState.UNASSIGNED, new UnassignedInfo(randomFrom(UnassignedInfo.Reason.values()), \"foobar\")));",
    "resolution": "1, randomBoolean(), ShardRoutingState.UNASSIGNED, new UnassignedInfo(randomFrom(UnassignedInfo.Reason.values()), \"foobar\")), TestShardRouting.newShardRouting(\"newest\", 0, null, null, null, 1, randomBoolean(), ShardRoutingState.UNASSIGNED, new UnassignedInfo(randomFrom(UnassignedInfo.Reason.values()), \"foobar\")));",
    "conflict": "1, randomBoolean(), ShardRoutingState.UNASSIGNED, 0, new UnassignedInfo(randomFrom(UnassignedInfo.Reason.values()), \"foobar\")), TestShardRouting.newShardRouting(\"newest\", 0, null, null, null, 1, randomBoolean(), ShardRoutingState.UNASSIGNED, 0, new UnassignedInfo(randomFrom(UnassignedInfo.Reason.values()), \"foobar\")));"
  },
  {
    "devdecision": "Manual",
    "id": 76369,
    "v2": "shards.add(TestShardRouting.newShardRouting(indexMeta.name, randomIntBetween(1, 5), null, null, null, randomBoolean(), ShardRoutingState.UNASSIGNED, new UnassignedInfo(randomFrom(UnassignedInfo.Reason.values()), \"foobar\")));",
    "resolution": "shards.add(TestShardRouting.newShardRouting(indexMeta.name, randomIntBetween(1, 5), null, null, null, 1, randomBoolean(), ShardRoutingState.UNASSIGNED, new UnassignedInfo(randomFrom(UnassignedInfo.Reason.values()), \"foobar\")));",
    "conflict": "shards.add(TestShardRouting.newShardRouting(indexMeta.name, randomIntBetween(1, 5), null, null, null, 1, randomBoolean(), ShardRoutingState.UNASSIGNED, randomIntBetween(0, 100), new UnassignedInfo(randomFrom(UnassignedInfo.Reason.values()), \"foobar\")));"
  },
  {
    "devdecision": "Combination",
    "id": 76374,
    "v2": "assertThat(create.version(), equalTo(1L));  create = new Engine.Index(newUid(\"1\"), doc, create.version(), create.versionType().versionTypeForReplicationAndRecovery(), REPLICA, 0);",
    "resolution": "assertThat(create.version(), equalTo(1L));  create = new Engine.Index(newUid(\"1\"), doc, create.seqNo(), create.version(), create.versionType().versionTypeForReplicationAndRecovery(), REPLICA, 0);",
    "conflict": "assertThat(create.version(), equalTo(1l)); create = new Engine.Index(newUid(\"1\"), doc, create.seqNo(), create.version(), create.versionType().versionTypeForReplicationAndRecovery(), REPLICA, 0);"
  },
  {
    "devdecision": "Manual",
    "id": 76394,
    "v2": "// test if we still write it even if the shard is not active ShardRouting inactiveRouting = TestShardRouting.newShardRouting(shard.shardRouting.index(), shard.shardRouting.shardId().id(), shard.shardRouting.currentNodeId(), null, null, true, ShardRoutingState.INITIALIZING);",
    "resolution": "// test if we still write it even if the shard is not active ShardRouting inactiveRouting = TestShardRouting.newShardRouting(shard.shardRouting.index(), shard.shardRouting.shardId().id(), shard.shardRouting.currentNodeId(), null, null, shard.shardRouting.primaryTerm(), true, ShardRoutingState.INITIALIZING);",
    "conflict": "// test if we don't write it if the shard is not active ShardRouting inactiveRouting = TestShardRouting.newShardRouting(shard.shardRouting.index(), shard.shardRouting.shardId().id(), shard.shardRouting.currentNodeId(), null, null, shard.shardRouting.primaryTerm(), true, ShardRoutingState.INITIALIZING, shard.shardRouting.version() + 1);"
  },
  {
    "devdecision": "Version 1",
    "id": 76400,
    "v2": "\"  \\\"operations\\\" : 6,\\n\" + \"  \\\"size_in_bytes\\\" : 431\\n\" + \"}\", copy.toString().trim());",
    "resolution": "\"  \\\"operations\\\" : 6,\\n\" + \"  \\\"size_in_bytes\\\" : 437\\n\" + \"}\", copy.toString().trim());",
    "conflict": "\"  \\\"operations\\\" : 6,\\n\" + \"  \\\"size_in_bytes\\\" : 437\\n\" + \"}\", copy.toString().trim());"
  },
  {
    "devdecision": "Manual",
    "id": 76407,
    "v2": "routingTable.addShard(TestShardRouting.newShardRouting(\"test\", i, nodeId, relocationNodeId, true, ShardRoutingState.STARTED)); for (int j = 0; j < numReplicas; j++) { routingTable.addShard(TestShardRouting.newShardRouting(\"test\", i, nodeId, relocationNodeId, false, ShardRoutingState.STARTED));",
    "resolution": "routingTable.addShard(TestShardRouting.newShardRouting(\"test\", i, nodeId, relocationNodeId, primaryTerm, true, ShardRoutingState.STARTED)); for (int j = 0; j < numReplicas; j++) { routingTable.addShard(TestShardRouting.newShardRouting(\"test\", i, nodeId, relocationNodeId, primaryTerm, false, ShardRoutingState.STARTED));",
    "conflict": "routingTable.addShard(TestShardRouting.newShardRouting(\"test\", i, nodeId, relocationNodeId, primaryTerm, true, ShardRoutingState.STARTED, 0)); for (int j = 0; j < numReplicas; j++) { routingTable.addShard(TestShardRouting.newShardRouting(\"test\", i, nodeId, relocationNodeId, primaryTerm, false, ShardRoutingState.STARTED, 0));"
  },
  {
    "devdecision": "Manual",
    "id": 76410,
    "v2": "routingTable.addShard(TestShardRouting.newShardRouting(\"test\", i, \"xyz\", \"def\", true, ShardRoutingState.STARTED)); for (int j = 0; j < numReplicas; j++) { routingTable.addShard(TestShardRouting.newShardRouting(\"test\", i, \"xyz\", \"def\", false, ShardRoutingState.STARTED));",
    "resolution": "routingTable.addShard(TestShardRouting.newShardRouting(\"test\", i, \"xyz\", \"def\", primaryTerm, true, ShardRoutingState.STARTED)); for (int j = 0; j < numReplicas; j++) { routingTable.addShard(TestShardRouting.newShardRouting(\"test\", i, \"xyz\", \"def\", primaryTerm, false, ShardRoutingState.STARTED));",
    "conflict": "routingTable.addShard(TestShardRouting.newShardRouting(\"test\", i, \"xyz\", \"def\", primaryTerm, true, ShardRoutingState.STARTED, 0)); for (int j = 0; j < numReplicas; j++) { routingTable.addShard(TestShardRouting.newShardRouting(\"test\", i, \"xyz\", \"def\", primaryTerm, false, ShardRoutingState.STARTED, 0));"
  },
  {
    "devdecision": "Version 1",
    "id": 76416,
    "v2": ".addAggregation(dateHistogram(\"histo\").field(\"f\").timeZone(\"+01:00\") .minDocCount(0).interval(DateHistogramInterval.MONTH)).get();",
    "resolution": ".addAggregation(dateHistogram(\"histo\").field(\"f\").timeZone(DateTimeZone.forID(\"+01:00\")).minDocCount(0) .dateHistogramInterval(DateHistogramInterval.MONTH)) .get();",
    "conflict": ".addAggregation(dateHistogram(\"histo\").field(\"f\").timeZone(DateTimeZone.forID(\"+01:00\")).minDocCount(0) .dateHistogramInterval(DateHistogramInterval.MONTH)) .get();"
  },
  {
    "devdecision": "Version 1",
    "id": 76421,
    "v2": "public String getText() { return this.globalText;",
    "resolution": "@Nullable public String getGlobalText() { return globalText;",
    "conflict": "@Nullable public String getGlobalText() { return globalText;"
  },
  {
    "devdecision": "Version 2",
    "id": 76422,
    "v2": "map.put(\"phrase\", PhraseSuggester.PROTOTYPE); map.put(\"term\", TermSuggester.PROTOTYPE); map.put(\"completion\", CompletionSuggester.PROTOTYPE);",
    "resolution": "map.put(\"phrase\", PhraseSuggester.PROTOTYPE); map.put(\"term\", TermSuggester.PROTOTYPE); map.put(\"completion\", CompletionSuggester.PROTOTYPE);",
    "conflict": "map.put(\"phrase\", new PhraseSuggester(scriptService)); map.put(\"term\", new TermSuggester()); map.put(\"completion\", new CompletionSuggester());"
  },
  {
    "devdecision": "Version 2",
    "id": 76426,
    "v2": "private Suggester<?> suggester;  protected SuggestionContext(Suggester<?> suggester, QueryShardContext shardContext) { this.suggester = suggester; this.shardContext = shardContext; }",
    "resolution": "private Suggester<?> suggester;  protected SuggestionContext(Suggester<?> suggester, QueryShardContext shardContext) { this.suggester = suggester; this.shardContext = shardContext; }",
    "conflict": ""
  },
  {
    "devdecision": "Version 2",
    "id": 76433,
    "v2": "",
    "resolution": "",
    "conflict": "MapperService getMapperService() { return mapperService; }"
  },
  {
    "devdecision": "Manual",
    "id": 76438,
    "v2": "// TODO remove this when field is mandatory in builder ctor if (suggestionContext.getField() == null) { throw new IllegalArgumentException(\"The required field option is missing\"); }",
    "resolution": "if (suggestionContext.model() == null) { suggestionContext.setModel(StupidBackoffScorer.FACTORY); }",
    "conflict": ""
  },
  {
    "devdecision": "Manual",
    "id": 76441,
    "v2": "protected SuggestionContext build(QueryShardContext context) throws IOException { // NORELEASE throw new UnsupportedOperationException();",
    "resolution": "protected SuggestionContext innerBuild(QueryShardContext context) throws IOException { TermSuggestionContext suggestionContext = new TermSuggestionContext(context);",
    "conflict": "protected SuggestionContext innerBuild(QueryShardContext context) throws IOException { TermSuggestionContext suggestionContext = new TermSuggestionContext(TermSuggester.PROTOTYPE); return fillSuggestionContext(suggestionContext);"
  },
  {
    "devdecision": "Manual",
    "id": 76453,
    "v2": "public SearchService(Settings settings, ClusterSettings clusterSettings, ClusterService clusterService, IndicesService indicesService, ThreadPool threadPool, ScriptService scriptService, PageCacheRecycler pageCacheRecycler, BigArrays bigArrays, DfsPhase dfsPhase, QueryPhase queryPhase, FetchPhase fetchPhase) {",
    "resolution": "public SearchService(Settings settings, ClusterSettings clusterSettings, ClusterService clusterService, IndicesService indicesService, ThreadPool threadPool, ScriptService scriptService, PageCacheRecycler pageCacheRecycler, BigArrays bigArrays, DfsPhase dfsPhase, QueryPhase queryPhase, FetchPhase fetchPhase, AggregatorParsers aggParsers) {",
    "conflict": "public SearchService(Settings settings, ClusterSettings clusterSettings, ClusterService clusterService, IndicesService indicesService, ThreadPool threadPool, ScriptService scriptService, PageCacheRecycler pageCacheRecycler, BigArrays bigArrays, DfsPhase dfsPhase, QueryPhase queryPhase, FetchPhase fetchPhase, IndicesRequestCache indicesQueryCache, AggregatorParsers aggParsers) {"
  },
  {
    "devdecision": "Version 1",
    "id": 76460,
    "v2": "public AggregatorFactory parse(String aggregationName, XContentParser parser, SearchContext context) throws IOException { ParsedQuery filter = context.getQueryShardContext().parseInnerFilter(parser);",
    "resolution": "public FilterAggregator.FilterAggregatorBuilder parse(String aggregationName, XContentParser parser, QueryParseContext context) throws IOException { QueryBuilder<?> filter = context.parseInnerQueryBuilder();",
    "conflict": "public FilterAggregator.FilterAggregatorBuilder parse(String aggregationName, XContentParser parser, QueryParseContext context) throws IOException { QueryBuilder<?> filter = context.parseInnerQueryBuilder();"
  },
  {
    "devdecision": "Combination",
    "id": 76494,
    "v2": "IndexService indexService, PageCacheRecycler pageCacheRecycler, BigArrays bigArrays, ScriptService scriptService, Query aliasFilter, ParseFieldMatcher parseFieldMatcher) { super(parseFieldMatcher);",
    "resolution": "IndexService indexService, PageCacheRecycler pageCacheRecycler, BigArrays bigArrays, ScriptService scriptService, Query aliasFilter, ParseFieldMatcher parseFieldMatcher, FetchPhase fetchPhase) { super(parseFieldMatcher);",
    "conflict": "IndexService indexService, PageCacheRecycler pageCacheRecycler, BigArrays bigArrays, ScriptService scriptService, Query aliasFilter, ParseFieldMatcher parseFieldMatcher, FetchPhase fetchPhase) { super(parseFieldMatcher, request);"
  },
  {
    "devdecision": "Combination",
    "id": 76514,
    "v2": "import org.elasticsearch.client.FilterClient; import org.elasticsearch.common.lucene.search.function.CombineFunction; import org.elasticsearch.common.network.NetworkModule;",
    "resolution": "import org.elasticsearch.common.inject.AbstractModule; import org.elasticsearch.common.inject.Inject; import org.elasticsearch.common.inject.Module; import org.elasticsearch.common.network.NetworkModule;",
    "conflict": "import org.elasticsearch.common.inject.AbstractModule; import org.elasticsearch.common.inject.Inject; import org.elasticsearch.common.inject.Module;"
  },
  {
    "devdecision": "Combination",
    "id": 76517,
    "v2": "URLRepository.SUPPORTED_PROTOCOLS_SETTING)));",
    "resolution": "URLRepository.SUPPORTED_PROTOCOLS_SETTING, ClusterModule.SHARDS_ALLOCATOR_TYPE_SETTING, EsExecutors.PROCESSORS_SETTING)));",
    "conflict": "URLRepository.SUPPORTED_PROTOCOLS_SETTING, Node.NODE_INGEST_SETTING, ClusterModule.SHARDS_ALLOCATOR_TYPE_SETTING, EsExecutors.PROCESSORS_SETTING)));"
  },
  {
    "devdecision": "Version 1",
    "id": 76526,
    "v2": "private final String[] keys; private boolean keyed; private String otherBucketKey;",
    "resolution": "private final boolean keyed; private boolean otherBucket = false; private String otherBucketKey = \"_other_\";",
    "conflict": "private final boolean keyed; private boolean otherBucket = false; private String otherBucketKey = \"_other_\";"
  },
  {
    "devdecision": "Combination",
    "id": 76530,
    "v2": ".put(Environment.PATH_CONF_SETTING.getKey(), getDataPath(\"/indices/analyze/conf_dir\")) .put(HUNSPELL_LAZY_LOAD, randomBoolean()) .put(HUNSPELL_IGNORE_CASE, true)",
    "resolution": ".put(Environment.PATH_CONF_SETTING.getKey(), getDataPath(\"/indices/analyze/conf_dir\")) .put(HUNSPELL_LAZY_LOAD.getKey(), randomBoolean()) .put(HUNSPELL_IGNORE_CASE.getKey(), true)",
    "conflict": ".put(\"path.conf\", getDataPath(\"/indices/analyze/conf_dir\")) .put(HUNSPELL_LAZY_LOAD.getKey(), randomBoolean()) .put(HUNSPELL_IGNORE_CASE.getKey(), true)"
  },
  {
    "devdecision": "Combination",
    "id": 76531,
    "v2": ".put(Environment.PATH_CONF_SETTING.getKey(), getDataPath(\"/indices/analyze/conf_dir\")) .put(HUNSPELL_LAZY_LOAD, randomBoolean()) .put(HUNSPELL_IGNORE_CASE, true)",
    "resolution": ".put(Environment.PATH_CONF_SETTING.getKey(), getDataPath(\"/indices/analyze/conf_dir\")) .put(HUNSPELL_LAZY_LOAD.getKey(), randomBoolean()) .put(HUNSPELL_IGNORE_CASE.getKey(), true)",
    "conflict": ".put(\"path.conf\", getDataPath(\"/indices/analyze/conf_dir\")) .put(HUNSPELL_LAZY_LOAD.getKey(), randomBoolean()) .put(HUNSPELL_IGNORE_CASE.getKey(), true)"
  },
  {
    "devdecision": "Version 1",
    "id": 76541,
    "v2": "}  protected BroadcastRequest(ActionRequest<?> originalRequest) { super(originalRequest);",
    "resolution": "",
    "conflict": ""
  },
  {
    "devdecision": "Version 1",
    "id": 76543,
    "v2": "}  protected MasterNodeRequest(ActionRequest<?> request) { super(request);",
    "resolution": "",
    "conflict": ""
  },
  {
    "devdecision": "Version 1",
    "id": 76544,
    "v2": "protected BaseNodesRequest(ActionRequest<?> request, String... nodesIds) { super(request); this.nodesIds = nodesIds; }",
    "resolution": "",
    "conflict": ""
  },
  {
    "devdecision": "Version 1",
    "id": 76545,
    "v2": "/** * Creates a new request that inherits headers and context from the request provided as argument. */ public ReplicationRequest(ActionRequest<?> request) { super(request); }",
    "resolution": "",
    "conflict": ""
  },
  {
    "devdecision": "Combination",
    "id": 76553,
    "v2": "public RestGetIndicesAction(Settings settings, RestController controller, Client client, IndexScopedSettings indexScopedSettings) { super(settings, controller, client); this.indexScopedSettings = indexScopedSettings;",
    "resolution": "public RestGetIndicesAction(Settings settings, RestController controller, Client client, IndexScopedSettings indexScopedSettings) { super(settings, client); this.indexScopedSettings = indexScopedSettings;",
    "conflict": "public RestGetIndicesAction(Settings settings, RestController controller, Client client) { super(settings, client);"
  },
  {
    "devdecision": "Combination",
    "id": 76554,
    "v2": "public RestGetSettingsAction(Settings settings, RestController controller, Client client, IndexScopedSettings indexScopedSettings) { super(settings, controller, client); this.indexScopedSettings = indexScopedSettings;",
    "resolution": "public RestGetSettingsAction(Settings settings, RestController controller, Client client, IndexScopedSettings indexScopedSettings) { super(settings, client); this.indexScopedSettings = indexScopedSettings;",
    "conflict": "public RestGetSettingsAction(Settings settings, RestController controller, Client client) { super(settings, client);"
  },
  {
    "devdecision": "Combination",
    "id": 76562,
    "v2": "import org.elasticsearch.common.xcontent.StatusToXContent; import org.elasticsearch.common.xcontent.XContentBuilder; import org.elasticsearch.common.xcontent.XContentBuilderString;",
    "resolution": "import org.elasticsearch.common.io.stream.Writeable; import org.elasticsearch.common.xcontent.StatusToXContent; import org.elasticsearch.common.xcontent.ToXContent; import org.elasticsearch.common.xcontent.XContentBuilder; import org.elasticsearch.common.xcontent.XContentBuilderString;",
    "conflict": "import org.elasticsearch.common.io.stream.Writeable; import org.elasticsearch.common.xcontent.ToXContent; import org.elasticsearch.common.xcontent.XContentBuilder;"
  },
  {
    "devdecision": "Manual",
    "id": 76565,
    "v2": "builder.sort(parser.text()); } else if (context.parseFieldMatcher().match(currentFieldName, PROFILE_FIELD)) { builder.profile = parser.booleanValue();",
    "resolution": "sort(parser.text()); } else if (context.parseFieldMatcher().match(currentFieldName, PROFILE_FIELD)) { profile = parser.booleanValue();",
    "conflict": "sorts = new ArrayList<>(); sort(parser.text());"
  },
  {
    "devdecision": "Combination",
    "id": 76573,
    "v2": "indexingOperationListeners.postIndex(index);",
    "resolution": "// Notify IMC so that it can go and check heap used by all indexing buffers periodically: indexingMemoryController.bytesWritten(index.getTranslogLocation().size);  indexingOperationListeners.postIndex(index);",
    "conflict": "indexingService.postIndex(index);  // Notify IMC so that it can go and check heap used by all indexing buffers periodically: indexingMemoryController.bytesWritten(index.getTranslogLocation().size);"
  },
  {
    "devdecision": "Combination",
    "id": 76574,
    "v2": "indexingOperationListeners.postDelete(delete);",
    "resolution": "// Notify IMC so that it can go and check heap used by all indexing buffers periodically: indexingMemoryController.bytesWritten(delete.getTranslogLocation().size);  indexingOperationListeners.postDelete(delete);",
    "conflict": "indexingService.postDelete(delete);  // Notify IMC so that it can go and check heap used by all indexing buffers periodically: indexingMemoryController.bytesWritten(delete.getTranslogLocation().size);"
  },
  {
    "devdecision": "Combination",
    "id": 76576,
    "v2": "threadPool, indexSettings, engineWarmer, store, deletionPolicy, mergePolicyConfig.getMergePolicy(), mergeSchedulerConfig, mapperService.indexAnalyzer(), similarityService.similarity(mapperService), codecService, shardEventListener, translogRecoveryPerformer, indexCache.query(), cachingPolicy, translogConfig, inactiveTime);",
    "resolution": "threadPool, indexSettings, engineWarmer, store, deletionPolicy, mergePolicyConfig.getMergePolicy(), mergeSchedulerConfig, mapperService.indexAnalyzer(), similarityService.similarity(mapperService), codecService, shardEventListener, translogRecoveryPerformer, indexCache.query(), cachingPolicy, translogConfig, idxSettings.getSettings().getAsTime(IndexingMemoryController.SHARD_INACTIVE_TIME_SETTING, IndexingMemoryController.SHARD_DEFAULT_INACTIVE_TIME));",
    "conflict": "threadPool, indexingService, indexSettings, engineWarmer, store, deletionPolicy, mergePolicyConfig.getMergePolicy(), mergeSchedulerConfig, mapperService.indexAnalyzer(), similarityService.similarity(mapperService), codecService, shardEventListener, translogRecoveryPerformer, indexCache.query(), cachingPolicy, translogConfig, idxSettings.getSettings().getAsTime(IndexingMemoryController.SHARD_INACTIVE_TIME_SETTING, IndexingMemoryController.SHARD_DEFAULT_INACTIVE_TIME));"
  },
  {
    "devdecision": "Combination",
    "id": 76580,
    "v2": "private final ScheduledFuture scheduler;",
    "resolution": "/** Contains shards currently being throttled because we can't write segments quickly enough */ private final Set<IndexShard> throttled = new HashSet<>();  private final ScheduledFuture scheduler;",
    "conflict": "/** Contains shards currently being throttled because we can't write segments quickly enough */ private final Set<IndexShard> throttled = new HashSet<>();  private volatile ScheduledFuture scheduler;"
  },
  {
    "devdecision": "Version 2",
    "id": 76598,
    "v2": "import org.elasticsearch.rest.BaseRestHandler; import org.elasticsearch.rest.RestChannel; import org.elasticsearch.rest.RestController; import org.elasticsearch.rest.RestRequest;",
    "resolution": "import org.elasticsearch.rest.BaseRestHandler; import org.elasticsearch.rest.RestChannel; import org.elasticsearch.rest.RestController; import org.elasticsearch.rest.RestRequest;",
    "conflict": "import org.elasticsearch.rest.*;"
  },
  {
    "devdecision": "Combination",
    "id": 76602,
    "v2": "import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked; import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount; import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertNoFailures; import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertSearchHits;",
    "resolution": "import static org.hamcrest.Matchers.containsString; import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked; import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount; import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertNoFailures; import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertSearchHits;",
    "conflict": "import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.*; import static org.hamcrest.Matchers.containsString;"
  },
  {
    "devdecision": "Combination",
    "id": 76608,
    "v2": "private volatile ByteSizeValue indexingBufferSize; private volatile ByteSizeValue versionMapSize; private volatile String versionMapSizeSetting;",
    "resolution": "private final ByteSizeValue indexingBufferSize;",
    "conflict": "private final ByteSizeValue indexingBufferSize; private volatile boolean compoundOnFlush = true;"
  },
  {
    "devdecision": "Combination",
    "id": 76612,
    "v2": "/** If we see no indexing operations after this much time for a given shard, we consider that shard inactive (default: 5 minutes). */ public static final String INDEX_SHARD_INACTIVE_TIME_SETTING = \"index.shard.inactive_time\"; private static final String INDICES_INACTIVE_TIME_SETTING = \"indices.memory.shard_inactive_time\";",
    "resolution": "public static final String INDEX_REFRESH_INTERVAL = \"index.refresh_interval\";",
    "conflict": "public static final String INDEX_TRANSLOG_DISABLE_FLUSH = \"index.translog.disable_flush\"; public static final String INDEX_REFRESH_INTERVAL = \"index.refresh_interval\";"
  },
  {
    "devdecision": "Version 1",
    "id": 76627,
    "v2": "final static ByteSizeValue INACTIVE = new ByteSizeValue(-1);  final Map<IndexShard, ByteSizeValue> indexingBuffers = new HashMap<>();",
    "resolution": "// Size of each shard's indexing buffer final Map<IndexShard, Long> indexBufferRAMBytesUsed = new HashMap<>();",
    "conflict": "// Size of each shard's indexing buffer final Map<IndexShard, Long> indexBufferRAMBytesUsed = new HashMap<>();"
  },
  {
    "devdecision": "Version 1",
    "id": 76635,
    "v2": ".put(IndexingMemoryController.INDEX_BUFFER_SIZE_SETTING, \"10mb\") .put(IndexShard.INDEX_SHARD_INACTIVE_TIME_SETTING, \"5s\") .build());",
    "resolution": ".put(IndexingMemoryController.INDEX_BUFFER_SIZE_SETTING, \"5mb\") .build());",
    "conflict": ".put(IndexingMemoryController.INDEX_BUFFER_SIZE_SETTING, \"5mb\") .build());"
  },
  {
    "devdecision": "Combination",
    "id": 76648,
    "v2": "modules.add(new EnvironmentModule(environment)); modules.add(new NodeModule(this, nodeSettingsService, monitorService)); modules.add(new NetworkModule(networkService, settings, false));",
    "resolution": "modules.add(new EnvironmentModule(environment)); modules.add(new NodeModule(this, monitorService)); modules.add(new NetworkModule(networkService, settings, false));",
    "conflict": "modules.add(new NodeModule(this,monitorService)); modules.add(new NetworkModule(networkService));"
  },
  {
    "devdecision": "Combination",
    "id": 76650,
    "v2": "IndexStoreConfig.INDICES_STORE_THROTTLE_MAX_BYTES_PER_SEC, RecoverySettings.INDICES_RECOVERY_MAX_BYTES_PER_SEC));",
    "resolution": "IndexStoreConfig.INDICES_STORE_THROTTLE_MAX_BYTES_PER_SEC_SETTING.getKey(), RecoverySettings.INDICES_RECOVERY_MAX_BYTES_PER_SEC_SETTING.getKey()));",
    "conflict": "IndexStoreConfig.INDICES_STORE_THROTTLE_MAX_BYTES_PER_SEC_SETTING.getKey(), RecoverySettings.INDICES_RECOVERY_FILE_CHUNK_SIZE_SETTING.getKey(), RecoverySettings.INDICES_RECOVERY_TRANSLOG_SIZE_SETTING.getKey(), RecoverySettings.INDICES_RECOVERY_MAX_BYTES_PER_SEC_SETTING.getKey()));"
  },
  {
    "devdecision": "Combination",
    "id": 76665,
    "v2": "private final IndexSettings indexSettings; private volatile ByteSizeValue indexingBufferSize; private volatile ByteSizeValue versionMapSize; private volatile String versionMapSizeSetting;",
    "resolution": "private final IndexSettings indexSettings; private final ByteSizeValue indexingBufferSize;",
    "conflict": "private final Settings indexSettings; private final ByteSizeValue indexingBufferSize;"
  },
  {
    "devdecision": "Manual",
    "id": 76679,
    "v2": "import java.util.*; import java.util.concurrent.ScheduledFuture;  public class IndexingMemoryController extends AbstractLifecycleComponent<IndexingMemoryController> implements IndexEventListener {",
    "resolution": "// nocommit what is IndexEventListener public class IndexingMemoryController extends AbstractLifecycleComponent<IndexingMemoryController> implements IndexEventListener {",
    "conflict": "public class IndexingMemoryController extends AbstractLifecycleComponent<IndexingMemoryController> {"
  },
  {
    "devdecision": "Manual",
    "id": 76697,
    "v2": ".put(IndexingMemoryController.INDEX_BUFFER_SIZE_SETTING, \"50%\") .put(IndexingMemoryController.TRANSLOG_BUFFER_SIZE_SETTING, \"0.5%\") .build());",
    "resolution": ".put(IndexingMemoryController.INDEX_BUFFER_SIZE_SETTING, \"50%\") .build());",
    "conflict": ".put(IndexingMemoryController.INDEX_BUFFER_SIZE_SETTING, \"50%\") .build());"
  },
  {
    "devdecision": "Version 1",
    "id": 76698,
    "v2": ".put(IndexingMemoryController.INDEX_BUFFER_SIZE_SETTING, \"0.001%\") .put(IndexingMemoryController.TRANSLOG_BUFFER_SIZE_SETTING, \"0.001%\") .put(IndexingMemoryController.MIN_INDEX_BUFFER_SIZE_SETTING, \"6mb\") .put(IndexingMemoryController.MIN_TRANSLOG_BUFFER_SIZE_SETTING, \"512kb\").build());",
    "resolution": ".put(IndexingMemoryController.INDEX_BUFFER_SIZE_SETTING, \"0.001%\") .put(IndexingMemoryController.MIN_INDEX_BUFFER_SIZE_SETTING, \"6mb\").build());",
    "conflict": ".put(IndexingMemoryController.INDEX_BUFFER_SIZE_SETTING, \"0.001%\") .put(IndexingMemoryController.MIN_INDEX_BUFFER_SIZE_SETTING, \"6mb\").build());"
  },
  {
    "devdecision": "Version 1",
    "id": 76711,
    "v2": "public Engine.Delete prepareDeleteOnReplica(String type, String id, long version, VersionType versionType) {",
    "resolution": "public Engine.Delete prepareDeleteOnReplica(String type, String id, long seqNo, long version, VersionType versionType) { if (shardRouting.primary() && shardRouting.isRelocationTarget() == false) { throw new IllegalIndexShardStateException(shardId, state, \"shard is not a replica\"); }",
    "conflict": "public Engine.Delete prepareDeleteOnReplica(String type, String id, long seqNo, long version, VersionType versionType) { if (shardRouting.primary() && shardRouting.isRelocationTarget() == false) { throw new IllegalIndexShardStateException(shardId, state, \"shard is not a replica\"); }"
  },
  {
    "devdecision": "Combination",
    "id": 76715,
    "v2": "updateResponse = new UpdateResponse(response.getShardInfo(), response.getShardId(), response.getType(), response.getId(), response.getVersion(), false); updateResponse.setGetResult(updateHelper.extractGetResult(updateRequest, request.index(), response.getVersion(), updateResult.result.updatedSourceAsMap(), updateResult.result.updateSourceContentType(), null));",
    "resolution": "updateResponse = new UpdateResponse(response.getShardInfo(), response.getShardId(), response.getType(), response.getId(), response.getSeqNo(), response.getVersion(), false); updateResponse.setGetResult(updateHelper.extractGetResult(updateRequest, request.index(), response.getVersion(), updateResult.result.updatedSourceAsMap(), updateResult.result.updateSourceContentType(), null));",
    "conflict": "updateResponse = new UpdateResponse(response.getShardInfo(), response.getShardId(), response.getType(), response.getId(), response.getSeqNo(), response.getVersion(), false); updateResponse.setGetResult(updateHelper.extractGetResult(updateRequest, shardRequest.request.index(), response.getVersion(), updateResult.result.updatedSourceAsMap(), updateResult.result.updateSourceContentType(), null));"
  },
  {
    "devdecision": "Manual",
    "id": 76734,
    "v2": "indexShardReference = getIndexShardOperationsCounter(shardId); Tuple<Response, ReplicaRequest> primaryResponse = shardOperationOnPrimary(state.metaData(), request);",
    "resolution": "indexShardReference = getIndexShardOperationsCounterOnPrimary(shardId); Tuple<Response, ReplicaRequest> primaryResponse = shardOperationOnPrimary(state.metaData(), request); primaryResponse.v2().primaryTerm(indexShardReference.opPrimaryTerm());",
    "conflict": "indexShardReference = getIndexShardOperationsCounter(primary.shardId(), primary.primaryTerm()); PrimaryOperationRequest por = new PrimaryOperationRequest(primary.id(), internalRequest.concreteIndex(), internalRequest.request()); Tuple<Response, ReplicaRequest> primaryResponse = shardOperationOnPrimary(observer.observedState(), por); primaryResponse.v2().primaryTerm(primary.primaryTerm());"
  },
  {
    "devdecision": "Version 1",
    "id": 76740,
    "v2": "totalShards, success.get(), failuresArray",
    "resolution": "totalShards, success.get(), failuresArray",
    "conflict": "totalShards, success.get(), failuresArray"
  },
  {
    "devdecision": "Version 1",
    "id": 76758,
    "v2": "threadPool, indexingService, indexSettings, engineWarmer, store, deletionPolicy, mergePolicyConfig.getMergePolicy(), mergeSchedulerConfig, mapperService.indexAnalyzer(), similarityService.similarity(mapperService), codecService, shardEventListener, translogRecoveryPerformer, indexCache.query(), cachingPolicy, translogConfig, inactiveTime);",
    "resolution": "threadPool, indexingService, indexSettings, engineWarmer, store, deletionPolicy, mergePolicyConfig.getMergePolicy(), mergeSchedulerConfig, mapperService.indexAnalyzer(), similarityService.similarity(mapperService), codecService, shardEventListener, translogRecoveryPerformer, indexCache.query(), cachingPolicy, translogConfig, inactiveTime);",
    "conflict": "threadPool, indexingService, indexSettings, engineWarmer, store, deletionPolicy, mergePolicyConfig.getMergePolicy(), mergeSchedulerConfig, mapperService.indexAnalyzer(), similarityService.similarity(mapperService), codecService, shardEventListener, translogRecoveryPerformer, indexCache.query(), cachingPolicy, translogConfig, inactiveTime);"
  },
  {
    "devdecision": "Manual",
    "id": 76789,
    "v2": "* @param changed a flag to determine whether the actual {@link RoutingTable} has been changed * @param routingTable the {@link RoutingTable} this Result references * @param metaData the {@link MetaData} this Result references",
    "resolution": "* * @param changed      a flag to determine whether the actual {@link RoutingTable} has been changed * @param routingTable the {@link RoutingTable} this Result references",
    "conflict": "*  @param changed a flag to determine whether the actual {@link RoutingTable} has been changed * @param routingTable the {@link RoutingTable} this Result references * @param metaData the {@link MetaData} this result refrences"
  },
  {
    "devdecision": "Combination",
    "id": 76802,
    "v2": "Collection<String> pluginNames = nodeInfo.getPlugins().getInfos().stream().map(p -> p.getName()).collect(Collectors.toList()); assertThat(\"plugin [\" + XPackPlugin.NAME + \"] not found in [\" + pluginNames + \"]\", pluginNames.contains(XPackPlugin.NAME), is(true));",
    "resolution": "Collection<String> pluginNames = nodeInfo.getPlugins().getPluginInfos().stream().map(p -> p.getName()).collect(Collectors.toList()); assertThat(\"plugin [\" + XPackPlugin.NAME + \"] not found in [\" + pluginNames + \"]\", pluginNames.contains(XPackPlugin.NAME), is(true));",
    "conflict": "Collection<String> pluginNames = nodeInfo.getPlugins().getPluginInfos().stream().map(p -> p.getName()).collect(Collectors.toList()); assertThat(\"plugin [\" + ShieldPlugin.NAME + \"] not found in [\" + pluginNames + \"]\", pluginNames.contains(ShieldPlugin.NAME), is(true)); assertThat(\"plugin [\" + licensePluginName() + \"] not found in [\" + pluginNames + \"]\", pluginNames.contains(licensePluginName()), is(true));"
  },
  {
    "devdecision": "Combination",
    "id": 76809,
    "v2": "if (logger.isTraceEnabled()) { logger.trace(\"operation completed on primary [{}], action [{}], request [{}], cluster state version [{}]\", primary, actionName, por.request, observer.observedState().version()); }",
    "resolution": "primaryResponse.v2().primaryTerm(primary.primaryTerm()); if (logger.isTraceEnabled()) { logger.trace(\"operation completed on primary [{}], action [{}], request [{}], cluster state version [{}]\", primary, actionName, por.request, observer.observedState().version()); }",
    "conflict": "primaryResponse.v2().primaryTerm(primary.primaryTerm()); logger.trace(\"operation completed on primary [{}]\", primary);"
  },
  {
    "devdecision": "Manual",
    "id": 76820,
    "v2": "prevRoutingTable = routingTable; routingTable = strategy.reroute(clusterState, \"reroute\").routingTable(); clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();",
    "resolution": "RoutingTable prevRoutingTable = clusterState.routingTable(); result = strategy.reroute(clusterState, \"reroute\"); clusterState = ClusterState.builder(clusterState).routingResult(result).build();",
    "conflict": "RoutingTable prevRoutingTable = clusterState.routingTable(); result = strategy.reroute(clusterState); clusterState = ClusterState.builder(clusterState).routingResult(result).build();"
  },
  {
    "devdecision": "Manual",
    "id": 76823,
    "v2": "addProcessor(SimpleProcessor.TYPE, new SimpleProcessor.Factory()); addProcessor(GeoIpProcessor.TYPE, new GeoIpProcessor.Factory()); addProcessor(GrokProcessor.TYPE, new GrokProcessor.Factory());",
    "resolution": "addProcessor(SimpleProcessor.TYPE, new SimpleProcessor.Factory()); addProcessor(GeoIpProcessor.TYPE, new GeoIpProcessor.Factory()); addProcessor(GrokProcessor.TYPE, new GrokProcessor.Factory());",
    "conflict": "registerProcessor(SimpleProcessor.TYPE, SimpleProcessor.Builder.Factory.class); registerProcessor(DateProcessor.TYPE, DateProcessor.Builder.Factory.class);"
  },
  {
    "devdecision": "Combination",
    "id": 76827,
    "v2": "public class ForceMergeBlocksIT extends ESIntegTestCase {  @Test public void testForceMergeWithBlocks() {",
    "resolution": "public class ForceMergeBlocksIT extends ESIntegTestCase {",
    "conflict": "public class OptimizeBlocksIT extends ESIntegTestCase { public void testOptimizeWithBlocks() {"
  },
  {
    "devdecision": "Manual",
    "id": 76829,
    "v2": "ShardSearchRequest request = new ShardSearchLocalRequest(indexShard.shardId(), indexMetaData.getNumberOfShards(), SearchType.QUERY_THEN_FETCH, entry.source(), entry.types(), entry.requestCache());",
    "resolution": "final IndexService indexService = indicesService.indexServiceSafe(indexShard.shardId().index().name()); ShardSearchRequest request = new ShardSearchLocalRequest(indexShard.shardId(), indexMetaData .getNumberOfShards(), SearchType.QUERY_THEN_FETCH, entry.source().build(new QueryParseContext(indexService.queryParserService().indicesQueriesRegistry())), entry.types(), entry.requestCache());",
    "conflict": "final IndexService indexService = indicesService.indexServiceSafe(indexShard.shardId().index().name()); ShardSearchRequest request = new ShardSearchLocalRequest(indexShard.shardId(), indexMetaData.numberOfShards(), SearchType.QUERY_THEN_FETCH, entry.source().build(new QueryParseContext(indexService.queryParserService().indicesQueriesRegistry())), entry.types(), entry.requestCache());"
  },
  {
    "devdecision": "None",
    "id": 76840,
    "v2": "import com.google.common.collect.ImmutableMap;",
    "resolution": "import org.apache.lucene.util.IOUtils;",
    "conflict": "import com.google.common.cache.Cache; import com.google.common.cache.CacheBuilder; import com.google.common.cache.RemovalListener; import com.google.common.cache.RemovalNotification;"
  },
  {
    "devdecision": "Version 2",
    "id": 76859,
    "v2": "",
    "resolution": "",
    "conflict": "import org.elasticsearch.index.termvectors.TermVectorsService; import org.elasticsearch.indices.IndicesLifecycle; import org.elasticsearch.indices.IndicesWarmer; import org.elasticsearch.indices.cache.query.IndicesQueryCache; import org.elasticsearch.indices.memory.IndexingMemoryController; import org.elasticsearch.threadpool.ThreadPool;"
  },
  {
    "devdecision": "Version 2",
    "id": 76871,
    "v2": "",
    "resolution": "",
    "conflict": "protected Collection<Class<? extends Plugin>> nodePlugins() { return Collections.singleton(GroovyPlugin.class); }  @Override"
  },
  {
    "devdecision": "Concatenation",
    "id": 76878,
    "v2": "import org.elasticsearch.plugins.Plugin; import org.elasticsearch.script.Script; import org.elasticsearch.script.ScriptService; import org.elasticsearch.script.groovy.GroovyPlugin;",
    "resolution": "import org.elasticsearch.index.query.QueryBuilders; import org.elasticsearch.script.ScriptService.ScriptType;import org.elasticsearch.plugins.Plugin; import org.elasticsearch.script.Script; import org.elasticsearch.script.ScriptService; import org.elasticsearch.script.groovy.GroovyPlugin;",
    "conflict": "import org.elasticsearch.index.query.QueryBuilders; import org.elasticsearch.script.ScriptService.ScriptType;"
  },
  {
    "devdecision": "Combination",
    "id": 76883,
    "v2": "import java.util.Collection; import java.util.Collections;  import static org.elasticsearch.index.query.QueryBuilders.matchAllQuery;",
    "resolution": "import java.util.Collection; import java.util.Collections; import java.util.concurrent.TimeUnit;",
    "conflict": "import java.util.concurrent.TimeUnit;"
  },
  {
    "devdecision": "Concatenation",
    "id": 76884,
    "v2": "import org.elasticsearch.search.sort.FieldSortBuilder; import org.elasticsearch.search.sort.GeoDistanceSortBuilder; import org.elasticsearch.search.sort.ScriptSortBuilder; import org.elasticsearch.search.sort.SortBuilders; import org.elasticsearch.search.sort.SortOrder;",
    "resolution": "import org.elasticsearch.search.builder.SearchSourceBuilder;import org.elasticsearch.search.sort.FieldSortBuilder; import org.elasticsearch.search.sort.GeoDistanceSortBuilder; import org.elasticsearch.search.sort.ScriptSortBuilder; import org.elasticsearch.search.sort.SortBuilders; import org.elasticsearch.search.sort.SortOrder;",
    "conflict": "import org.elasticsearch.search.builder.SearchSourceBuilder;"
  },
  {
    "devdecision": "Version 2",
    "id": 76887,
    "v2": "// TODO: refactor into unit test, or, proper REST test public class GroovySecurityTests extends ESIntegTestCase {",
    "resolution": "// TODO: refactor into unit test, or, proper REST test public class GroovySecurityTests extends ESIntegTestCase {",
    "conflict": "public class GroovySecurityIT extends ESIntegTestCase {"
  },
  {
    "devdecision": "Combination",
    "id": 76899,
    "v2": "",
    "resolution": "import org.elasticsearch.common.ParseFieldMatcher; import org.elasticsearch.common.bytes.BytesReference; import org.elasticsearch.common.lease.Releasables; import org.elasticsearch.common.xcontent.XContent; import org.elasticsearch.common.xcontent.XContentFactory;",
    "conflict": "import org.elasticsearch.common.ParsingException; import org.elasticsearch.common.bytes.BytesReference; import org.elasticsearch.common.lease.Releasables; import org.elasticsearch.common.xcontent.XContent; import org.elasticsearch.common.xcontent.XContentFactory;"
  },
  {
    "devdecision": "Version 2",
    "id": 76904,
    "v2": "* stopwords. This query basically builds 2 queries off the {@code #add(Term) * added} terms where low-frequency terms are added to a required boolean clause",
    "resolution": "* stopwords. This query basically builds 2 queries off the {@code #add(Term) * added} terms where low-frequency terms are added to a required boolean clause",
    "conflict": "* stopwords. This query basically builds 2 queries off the * {@link org.apache.lucene.queries.CommonTermsQuery#add(Term) added} terms * where low-frequency terms are added to a required boolean clause"
  },
  {
    "devdecision": "Combination",
    "id": 76907,
    "v2": "private ParseFieldMatcher parseFieldMatcher = ParseFieldMatcher.EMPTY;",
    "resolution": "private final Index index; //norelease this flag is also used in the QueryShardContext, we need to make sure we set it there correctly in doToQuery() private ParseFieldMatcher parseFieldMatcher = ParseFieldMatcher.EMPTY;",
    "conflict": "private final Index index; //norelease this flag is also used in the QueryShardContext, we need to make sure we set it there correctly in doToQuery() private ParseFieldMatcher parseFieldMatcher;"
  },
  {
    "devdecision": "Version 1",
    "id": 76923,
    "v2": "String analyzer = parser.text(); if (parseContext.analysisService().analyzer(analyzer) == null) { throw new ParsingException(parseContext, \"[common] analyzer [\" + parser.text() + \"] not found\"); } queryAnalyzer = analyzer;",
    "resolution": "analyzer = parser.text();",
    "conflict": "analyzer = parser.text();"
  },
  {
    "devdecision": "Manual",
    "id": 76933,
    "v2": "Query query = parseContext.parseInnerQuery(); if (!(query instanceof SpanQuery)) { throw new ParsingException(parseContext, \"[field_masking_span] query] must be of type span query\");",
    "resolution": "QueryBuilder query = parseContext.parseInnerQueryBuilder(); if (!(query instanceof SpanQueryBuilder)) { throw new ParsingException(parseContext, \"[field_masking_span] query must be of type span query\");",
    "conflict": "QueryBuilder query = parseContext.parseInnerQueryBuilder(); if (!(query instanceof SpanQueryBuilder)) { throw new QueryParsingException(parseContext, \"[field_masking_span] query must be of type span query\");"
  },
  {
    "devdecision": "Combination",
    "id": 76963,
    "v2": "BytesRef value = parser.utf8BytesOrNull(); if (value == null) { throw new ParsingException(parseContext, \"No value specified for term filter\");",
    "resolution": "String id = parser.textOrNull(); if (id == null) { throw new ParsingException(parseContext, \"No value specified for term filter\");",
    "conflict": "String id = parser.textOrNull(); if (id == null) { throw new QueryParsingException(parseContext, \"No value specified for term filter\");"
  },
  {
    "devdecision": "Combination",
    "id": 76978,
    "v2": "import org.apache.lucene.queries.ExtendedCommonTermsQuery; import org.apache.lucene.search.BooleanClause; import org.apache.lucene.search.BooleanQuery; import org.apache.lucene.search.Query; import org.elasticsearch.common.ParsingException;",
    "resolution": "import org.apache.lucene.search.FuzzyQuery; import org.elasticsearch.common.ParsingException;",
    "conflict": "import org.apache.lucene.search.FuzzyQuery;"
  },
  {
    "devdecision": "Version 1",
    "id": 76980,
    "v2": "String analyzer = parser.text(); if (parseContext.analysisService().analyzer(analyzer) == null) { throw new ParsingException(parseContext, \"[match] analyzer [\" + parser.text() + \"] not found\"); } matchQuery.setAnalyzer(analyzer);",
    "resolution": "analyzer = parser.text();",
    "conflict": "analyzer = parser.text();"
  },
  {
    "devdecision": "Combination",
    "id": 76989,
    "v2": "import org.apache.lucene.search.BooleanClause; import org.apache.lucene.search.Query; import org.elasticsearch.common.ParsingException; import org.elasticsearch.common.inject.Inject; import org.elasticsearch.common.regex.Regex;",
    "resolution": "import org.elasticsearch.common.ParsingException;",
    "conflict": ""
  },
  {
    "devdecision": "Version 1",
    "id": 76992,
    "v2": "String analyzer = parser.text(); if (parseContext.analysisService().analyzer(analyzer) == null) { throw new ParsingException(parseContext, \"[\" + NAME + \"] analyzer [\" + parser.text() + \"] not found\"); } multiMatchQuery.setAnalyzer(analyzer);",
    "resolution": "analyzer = parser.text();",
    "conflict": "analyzer = parser.text();"
  },
  {
    "devdecision": "Manual",
    "id": 77006,
    "v2": "public Query parseInnerFilter(String queryName) throws IOException, ParsingException { final boolean originalIsFilter = isFilter;",
    "resolution": "//norelease setting and checking the isFilter Flag should completely be moved to toQuery/toFilter after query refactoring public QueryBuilder parseInnerFilterToQueryBuilder(String queryName) throws IOException { final boolean originalIsFilter = this.shardContext.isFilter;",
    "conflict": "//norelease setting and checking the isFilter Flag should completely be moved to toQuery/toFilter after query refactoring public QueryBuilder parseInnerFilterToQueryBuilder(String queryName) throws IOException, QueryParsingException { final boolean originalIsFilter = this.shardContext.isFilter;"
  },
  {
    "devdecision": "Combination",
    "id": 77015,
    "v2": "import org.elasticsearch.common.ParsingException; import org.elasticsearch.common.inject.Inject; import org.elasticsearch.common.joda.DateMathParser; import org.elasticsearch.common.joda.Joda; import org.elasticsearch.common.lucene.BytesRefs;",
    "resolution": "import org.elasticsearch.common.ParseField; import org.elasticsearch.common.ParsingException; import org.elasticsearch.common.xcontent.XContentParser;",
    "conflict": ""
  },
  {
    "devdecision": "Combination",
    "id": 77029,
    "v2": "Query query = parseContext.parseInnerQuery(); if (!(query instanceof SpanQuery)) { throw new ParsingException(parseContext, \"span_containing [big] must be of type span query\");",
    "resolution": "QueryBuilder query = parseContext.parseInnerQueryBuilder(); if (!(query instanceof SpanQueryBuilder<?>)) { throw new ParsingException(parseContext, \"span_containing [big] must be of type span query\");",
    "conflict": "QueryBuilder query = parseContext.parseInnerQueryBuilder(); if (!(query instanceof SpanQueryBuilder<?>)) { throw new QueryParsingException(parseContext, \"span_containing [big] must be of type span query\");"
  },
  {
    "devdecision": "Combination",
    "id": 77030,
    "v2": "Query query = parseContext.parseInnerQuery(); if (!(query instanceof SpanQuery)) { throw new ParsingException(parseContext, \"span_containing [little] must be of type span query\");",
    "resolution": "QueryBuilder query = parseContext.parseInnerQueryBuilder(); if (!(query instanceof SpanQueryBuilder<?>)) { throw new ParsingException(parseContext, \"span_containing [little] must be of type span query\");",
    "conflict": "QueryBuilder query = parseContext.parseInnerQueryBuilder(); if (!(query instanceof SpanQueryBuilder<?>)) { throw new QueryParsingException(parseContext, \"span_containing [little] must be of type span query\");"
  },
  {
    "devdecision": "Combination",
    "id": 77034,
    "v2": "Query query = parseContext.parseInnerQuery(); if (!(query instanceof SpanQuery)) { throw new ParsingException(parseContext, \"spanFirst [match] must be of type span query\");",
    "resolution": "QueryBuilder query = parseContext.parseInnerQueryBuilder(); if (!(query instanceof SpanQueryBuilder)) { throw new ParsingException(parseContext, \"spanFirst [match] must be of type span query\");",
    "conflict": "QueryBuilder query = parseContext.parseInnerQueryBuilder(); if (!(query instanceof SpanQueryBuilder)) { throw new QueryParsingException(parseContext, \"spanFirst [match] must be of type span query\");"
  },
  {
    "devdecision": "Combination",
    "id": 77040,
    "v2": "Query query = parseContext.parseInnerQuery(); if (!(query instanceof SpanQuery)) { throw new ParsingException(parseContext, \"spanNear [clauses] must be of type span query\");",
    "resolution": "QueryBuilder query = parseContext.parseInnerQueryBuilder(); if (!(query instanceof SpanQueryBuilder)) { throw new ParsingException(parseContext, \"spanNear [clauses] must be of type span query\");",
    "conflict": "QueryBuilder query = parseContext.parseInnerQueryBuilder(); if (!(query instanceof SpanQueryBuilder)) { throw new QueryParsingException(parseContext, \"spanNear [clauses] must be of type span query\");"
  },
  {
    "devdecision": "Combination",
    "id": 77043,
    "v2": "Query query = parseContext.parseInnerQuery(); if (!(query instanceof SpanQuery)) { throw new ParsingException(parseContext, \"spanNot [include] must be of type span query\");",
    "resolution": "QueryBuilder query = parseContext.parseInnerQueryBuilder(); if (!(query instanceof SpanQueryBuilder)) { throw new ParsingException(parseContext, \"spanNot [include] must be of type span query\");",
    "conflict": "QueryBuilder query = parseContext.parseInnerQueryBuilder(); if (!(query instanceof SpanQueryBuilder)) { throw new QueryParsingException(parseContext, \"spanNot [include] must be of type span query\");"
  },
  {
    "devdecision": "Combination",
    "id": 77044,
    "v2": "Query query = parseContext.parseInnerQuery(); if (!(query instanceof SpanQuery)) { throw new ParsingException(parseContext, \"spanNot [exclude] must be of type span query\");",
    "resolution": "QueryBuilder query = parseContext.parseInnerQueryBuilder(); if (!(query instanceof SpanQueryBuilder)) { throw new ParsingException(parseContext, \"spanNot [exclude] must be of type span query\");",
    "conflict": "QueryBuilder query = parseContext.parseInnerQueryBuilder(); if (!(query instanceof SpanQueryBuilder)) { throw new QueryParsingException(parseContext, \"spanNot [exclude] must be of type span query\");"
  },
  {
    "devdecision": "Combination",
    "id": 77047,
    "v2": "Query query = parseContext.parseInnerQuery(); if (!(query instanceof SpanQuery)) { throw new ParsingException(parseContext, \"spanOr [clauses] must be of type span query\");",
    "resolution": "QueryBuilder query = parseContext.parseInnerQueryBuilder(); if (!(query instanceof SpanQueryBuilder)) { throw new ParsingException(parseContext, \"spanOr [clauses] must be of type span query\");",
    "conflict": "QueryBuilder query = parseContext.parseInnerQueryBuilder(); if (!(query instanceof SpanQueryBuilder)) { throw new QueryParsingException(parseContext, \"spanOr [clauses] must be of type span query\");"
  },
  {
    "devdecision": "Combination",
    "id": 77048,
    "v2": "import org.apache.lucene.index.Term; import org.apache.lucene.search.Query; import org.apache.lucene.search.spans.SpanTermQuery; import org.apache.lucene.util.BytesRef; import org.elasticsearch.common.ParsingException;",
    "resolution": "import org.elasticsearch.common.ParsingException;",
    "conflict": ""
  },
  {
    "devdecision": "Combination",
    "id": 77052,
    "v2": "Query query = parseContext.parseInnerQuery(); if (query instanceof SpanQuery == false) { throw new ParsingException(parseContext, \"span_within [big] must be of type span query\");",
    "resolution": "QueryBuilder query = parseContext.parseInnerQueryBuilder(); if (query instanceof SpanQueryBuilder == false) { throw new ParsingException(parseContext, \"span_within [big] must be of type span query\");",
    "conflict": "QueryBuilder query = parseContext.parseInnerQueryBuilder(); if (query instanceof SpanQueryBuilder == false) { throw new QueryParsingException(parseContext, \"span_within [big] must be of type span query\");"
  },
  {
    "devdecision": "Combination",
    "id": 77053,
    "v2": "Query query = parseContext.parseInnerQuery(); if (query instanceof SpanQuery == false) { throw new ParsingException(parseContext, \"span_within [little] must be of type span query\");",
    "resolution": "QueryBuilder query = parseContext.parseInnerQueryBuilder(); if (query instanceof SpanQueryBuilder == false) { throw new ParsingException(parseContext, \"span_within [little] must be of type span query\");",
    "conflict": "QueryBuilder query = parseContext.parseInnerQueryBuilder(); if (query instanceof SpanQueryBuilder == false) { throw new QueryParsingException(parseContext, \"span_within [little] must be of type span query\");"
  },
  {
    "devdecision": "Combination",
    "id": 77061,
    "v2": "import org.apache.lucene.index.Term; import org.apache.lucene.search.Query; import org.apache.lucene.search.WildcardQuery; import org.apache.lucene.util.BytesRef; import org.elasticsearch.common.ParsingException;",
    "resolution": "import org.elasticsearch.common.ParsingException;",
    "conflict": ""
  },
  {
    "devdecision": "Version 1",
    "id": 77090,
    "v2": "import org.elasticsearch.common.ParsingException; import org.elasticsearch.script.ExecutableScript; import org.elasticsearch.script.Script;",
    "resolution": "import org.elasticsearch.index.query.QueryShardException; import org.elasticsearch.script.*;",
    "conflict": "import org.elasticsearch.index.query.QueryShardException; import org.elasticsearch.script.*;"
  },
  {
    "devdecision": "Version 1",
    "id": 77098,
    "v2": "import org.elasticsearch.index.query.QueryBuilder; import org.elasticsearch.index.query.QueryParseContext; import org.elasticsearch.index.query.QueryParser; import org.elasticsearch.common.ParsingException;",
    "resolution": "import org.elasticsearch.index.query.*;",
    "conflict": "import org.elasticsearch.index.query.*;"
  },
  {
    "devdecision": "Version 1",
    "id": 77100,
    "v2": "import org.elasticsearch.index.query.QueryParseContext; import org.elasticsearch.index.query.QueryParser; import org.elasticsearch.common.ParsingException; import org.elasticsearch.index.query.TermQueryParser;",
    "resolution": "import org.elasticsearch.index.query.*;",
    "conflict": "import org.elasticsearch.index.query.*;"
  },
  {
    "devdecision": "Manual",
    "id": 77129,
    "v2": "this.clusterName = clusterName; this.pendingStatesQueue = new PendingClusterStatesQueue(logger, settings.getAsInt(SETTINGS_MAX_PENDING_CLUSTER_STATES, 25)); transportService.registerRequestHandler(SEND_ACTION_NAME, BytesTransportRequest.class, ThreadPool.Names.SAME, new SendClusterStateRequestHandler()); transportService.registerRequestHandler(COMMIT_ACTION_NAME, CommitClusterStateRequest.class, ThreadPool.Names.SAME, new CommitClusterStateRequestHandler());",
    "resolution": "this.clusterName = clusterName; this.pendingStatesQueue = new PendingClusterStatesQueue(logger, settings.getAsInt(SETTINGS_MAX_PENDING_CLUSTER_STATES, 25)); transportService.registerRequestHandler(SEND_ACTION_NAME, BytesTransportRequest::new, ThreadPool.Names.SAME, new SendClusterStateRequestHandler()); transportService.registerRequestHandler(COMMIT_ACTION_NAME, CommitClusterStateRequest::new, ThreadPool.Names.SAME, new CommitClusterStateRequestHandler());",
    "conflict": "transportService.registerRequestHandler(ACTION_NAME, BytesTransportRequest::new, ThreadPool.Names.SAME, new PublishClusterStateRequestHandler());"
  },
  {
    "devdecision": "Manual",
    "id": 77135,
    "v2": "ScoreMode scoreMode = ScoreMode.None; int minChildren = 0; int maxChildren = Integer.MAX_VALUE;",
    "resolution": "ScoreMode scoreMode = HasChildQueryBuilder.DEFAULT_SCORE_MODE; int minChildren = HasChildQueryBuilder.DEFAULT_MIN_CHILDREN; int maxChildren = HasChildQueryBuilder.DEFAULT_MAX_CHILDREN;",
    "conflict": "ScoreType scoreType = ScoreType.NONE; int minChildren = HasChildQueryBuilder.DEFAULT_MIN_CHILDREN; int maxChildren = HasChildQueryBuilder.DEFAULT_MAX_CHILDREN;"
  },
  {
    "devdecision": "Combination",
    "id": 77144,
    "v2": "import org.elasticsearch.index.query.QueryParseContext; import org.elasticsearch.index.query.QueryParser; import org.elasticsearch.index.query.QueryParsingException;",
    "resolution": "import org.elasticsearch.index.query.*;",
    "conflict": "import org.elasticsearch.index.query.*; import org.elasticsearch.index.query.functionscore.factor.FactorParser;"
  },
  {
    "devdecision": "Combination",
    "id": 77145,
    "v2": "import org.elasticsearch.common.util.set.Sets; import org.elasticsearch.common.xcontent.ToXContent; import org.elasticsearch.common.xcontent.XContentBuilder; import org.elasticsearch.common.xcontent.XContentFactory; import org.elasticsearch.common.xcontent.XContentLocation;",
    "resolution": "import org.elasticsearch.common.util.set.Sets;",
    "conflict": ""
  },
  {
    "devdecision": "Combination",
    "id": 77156,
    "v2": "import org.elasticsearch.index.query.QueryParsingException; import org.elasticsearch.index.query.functionscore.weight.WeightBuilder; import org.elasticsearch.index.query.support.QueryInnerHitBuilder;",
    "resolution": "import org.elasticsearch.index.query.QueryShardException; import org.elasticsearch.index.query.support.QueryInnerHits; import org.elasticsearch.index.query.QueryParsingException;",
    "conflict": "import org.elasticsearch.index.query.QueryShardException; import org.elasticsearch.index.query.functionscore.factor.FactorBuilder; import org.elasticsearch.index.query.support.QueryInnerHits;"
  },
  {
    "devdecision": "Version 1",
    "id": 77212,
    "v2": "Map<Version, BytesReference> serializedStates = new HashMap<>(); Map<Version, BytesReference> serializedDiffs = new HashMap<>();",
    "resolution": "private void innerPublish(final ClusterChangedEvent clusterChangedEvent, final Set<DiscoveryNode> nodesToPublishTo, final SendingController sendingController, final boolean sendFullVersion, final Map<Version, BytesReference> serializedStates, final Map<Version, BytesReference> serializedDiffs) {",
    "conflict": "private void innerPublish(final ClusterChangedEvent clusterChangedEvent, final Set<DiscoveryNode> nodesToPublishTo, final SendingController sendingController, final boolean sendFullVersion, final Map<Version, BytesReference> serializedStates, final Map<Version, BytesReference> serializedDiffs) {"
  },
  {
    "devdecision": "Manual",
    "id": 77214,
    "v2": "import static org.hamcrest.Matchers.empty; import static org.hamcrest.Matchers.equalTo; import static org.hamcrest.Matchers.isOneOf; import static org.hamcrest.Matchers.not;",
    "resolution": "import static org.hamcrest.Matchers.*;",
    "conflict": "import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertNoTimeout; import static org.hamcrest.Matchers.*;"
  },
  {
    "devdecision": "Version 2",
    "id": 77216,
    "v2": "import org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse; import org.elasticsearch.action.admin.cluster.reroute.ClusterRerouteResponse; import org.elasticsearch.action.admin.indices.flush.FlushResponse; import org.elasticsearch.action.admin.indices.refresh.RefreshResponse; import org.elasticsearch.action.count.CountResponse;",
    "resolution": "import org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse; import org.elasticsearch.action.admin.cluster.reroute.ClusterRerouteResponse; import org.elasticsearch.action.admin.indices.flush.FlushResponse; import org.elasticsearch.action.admin.indices.refresh.RefreshResponse; import org.elasticsearch.action.count.CountResponse;",
    "conflict": ""
  },
  {
    "devdecision": "Concatenation",
    "id": 77225,
    "v2": "// TODO: remove when https://github.com/elastic/elasticsearch/issues/13326 is fixed",
    "resolution": "// TODO: remove when https://github.com/elastic/elasticsearch/issues/13326 is fixed/** * Parser for query filter * @deprecated use any query instead directly, possible since queries and filters are merged. */",
    "conflict": "/** * Parser for query filter * @deprecated use any query instead directly, possible since queries and filters are merged. */"
  },
  {
    "devdecision": "Version 1",
    "id": 77227,
    "v2": "import com.google.common.collect.ImmutableMap; import org.apache.lucene.analysis.Analyzer; import org.apache.lucene.queryparser.classic.MapperQueryParser; import org.apache.lucene.queryparser.classic.QueryParserSettings; import org.apache.lucene.search.Filter;",
    "resolution": "",
    "conflict": ""
  },
  {
    "devdecision": "Version 2",
    "id": 77234,
    "v2": "import static org.elasticsearch.index.query.QueryBuilders.boolQuery; import static org.elasticsearch.index.query.QueryBuilders.hasChildQuery; import static org.elasticsearch.index.query.QueryBuilders.matchAllQuery; import static org.elasticsearch.index.query.QueryBuilders.matchQuery;",
    "resolution": "import static org.elasticsearch.index.query.QueryBuilders.boolQuery; import static org.elasticsearch.index.query.QueryBuilders.hasChildQuery; import static org.elasticsearch.index.query.QueryBuilders.matchAllQuery; import static org.elasticsearch.index.query.QueryBuilders.matchQuery;",
    "conflict": "import static org.elasticsearch.index.query.QueryBuilders.*;"
  },
  {
    "devdecision": "Version 1",
    "id": 77240,
    "v2": "import org.apache.lucene.index.IndexReader; import org.apache.lucene.index.MultiDocValues; import org.apache.lucene.search.IndexSearcher; import org.apache.lucene.search.Query; import org.apache.lucene.search.join.JoinUtil; import org.apache.lucene.search.join.ScoreMode;",
    "resolution": "",
    "conflict": ""
  },
  {
    "devdecision": "Combination",
    "id": 77242,
    "v2": "int minChildren = 0; int maxChildren = 0;",
    "resolution": "int minChildren = HasChildQueryBuilder.DEFAULT_MIN_CHILDREN; int maxChildren = HasChildQueryBuilder.DEFAULT_MAX_CHILDREN;",
    "conflict": "int minChildren = HasChildQueryBuilder.DEFAULT_MIN_CHILDREN; int maxChildren = HasChildQueryBuilder.DEFAULT_MAX_CHILDREN; int shortCircuitParentDocSet = HasChildQueryBuilder.DEFAULT_SHORT_CIRCUIT_CUTOFF;"
  },
  {
    "devdecision": "Combination",
    "id": 77321,
    "v2": "import org.elasticsearch.common.util.CancellableThreadsTests; import org.elasticsearch.common.xcontent.*;",
    "resolution": "import org.elasticsearch.common.xcontent.ToXContent; import org.elasticsearch.common.xcontent.XContentBuilder; import org.elasticsearch.common.xcontent.XContentFactory; import org.elasticsearch.common.xcontent.XContentLocation;",
    "conflict": "import org.elasticsearch.common.xcontent.ToXContent; import org.elasticsearch.common.xcontent.XContentBuilder; import org.elasticsearch.common.xcontent.XContentFactory; import org.elasticsearch.common.xcontent.XContentLocation;"
  },
  {
    "devdecision": "None",
    "id": 77323,
    "v2": "import com.google.common.collect.Iterables;  import org.apache.lucene.queries.TermsQuery; import org.apache.lucene.search.Query; import org.apache.lucene.util.BytesRef;",
    "resolution": "import org.elasticsearch.common.inject.Inject;",
    "conflict": "import com.google.common.collect.ImmutableList;"
  },
  {
    "devdecision": "Version 1",
    "id": 77337,
    "v2": "import org.elasticsearch.index.query.QueryParsingException; import org.elasticsearch.script.ExecutableScript; import org.elasticsearch.script.Script;",
    "resolution": "import org.elasticsearch.index.query.QueryShardException; import org.elasticsearch.script.*;",
    "conflict": "import org.elasticsearch.index.query.QueryShardException; import org.elasticsearch.script.*;"
  },
  {
    "devdecision": "Manual",
    "id": 77382,
    "v2": "List<BooleanClause> clauses = new ArrayList<>(); boolean adjustPureNegative = true;",
    "resolution": "final List<QueryBuilder> mustClauses = new ArrayList<>(); final List<QueryBuilder> mustNotClauses = new ArrayList<>(); final List<QueryBuilder> shouldClauses = new ArrayList<>(); final List<QueryBuilder> filterClauses = new ArrayList<>();",
    "conflict": "final List<QueryBuilder> mustClauses = newArrayList(); final List<QueryBuilder> mustNotClauses = newArrayList(); final List<QueryBuilder> shouldClauses = newArrayList(); final List<QueryBuilder> filterClauses = newArrayList();"
  },
  {
    "devdecision": "Version 2",
    "id": 77387,
    "v2": "import org.apache.lucene.search.Filter; import org.apache.lucene.search.IndexSearcher; import org.apache.lucene.search.Query; import org.apache.lucene.search.QueryWrapperFilter;",
    "resolution": "import org.apache.lucene.search.Filter; import org.apache.lucene.search.IndexSearcher; import org.apache.lucene.search.Query; import org.apache.lucene.search.QueryWrapperFilter;",
    "conflict": "import org.apache.lucene.search.*;"
  },
  {
    "devdecision": "Combination",
    "id": 77397,
    "v2": "import org.apache.lucene.index.Term; import org.apache.lucene.search.MultiTermQuery; import org.apache.lucene.search.PrefixQuery; import org.apache.lucene.search.Query; import org.elasticsearch.common.ParseField;",
    "resolution": "import org.elasticsearch.common.ParseField;",
    "conflict": ""
  },
  {
    "devdecision": "Combination",
    "id": 77398,
    "v2": "import org.apache.lucene.index.Term; import org.apache.lucene.search.MultiTermQuery; import org.apache.lucene.search.Query; import org.apache.lucene.search.RegexpQuery; import org.apache.lucene.util.automaton.Operations; import org.elasticsearch.common.ParseField;",
    "resolution": "import org.elasticsearch.common.ParseField;",
    "conflict": ""
  },
  {
    "devdecision": "Combination",
    "id": 77421,
    "v2": "// Rebalancing is causing some checks after restore to randomly fail // due to https://github.com/elastic/elasticsearch/issues/9421 .put(EnableAllocationDecider.CLUSTER_ROUTING_REBALANCE_ENABLE, EnableAllocationDecider.Rebalance.NONE) .extendArray(\"plugin.types\", MockRepositoryPlugin.class.getName()).build();",
    "resolution": "// Rebalancing is causing some checks after restore to randomly fail // due to https://github.com/elastic/elasticsearch/issues/9421 .put(EnableAllocationDecider.CLUSTER_ROUTING_REBALANCE_ENABLE, EnableAllocationDecider.Rebalance.NONE) .extendArray(\"plugin.types\", MockRepository.Plugin.class.getName()).build();",
    "conflict": ".extendArray(\"plugin.types\", MockRepository.Plugin.class.getName()).build();"
  },
  {
    "devdecision": "Manual",
    "id": 77432,
    "v2": "MappedFieldType fieldType = parseContext.fieldMapper(fieldName);",
    "resolution": "MappedFieldType fieldType = parseContext.shardContext().fieldMapper(fieldName);",
    "conflict": "if (normalizeLat || normalizeLon) { GeoUtils.normalizePoint(point, normalizeLat, normalizeLon); }  MappedFieldType fieldType = context.fieldMapper(fieldName);"
  },
  {
    "devdecision": "Manual",
    "id": 77436,
    "v2": "MappedFieldType fieldType = parseContext.fieldMapper(fieldName);",
    "resolution": "MappedFieldType fieldType = parseContext.shardContext().fieldMapper(fieldName);",
    "conflict": "if (normalizeLat || normalizeLon) { GeoUtils.normalizePoint(point, normalizeLat, normalizeLon); }  MappedFieldType fieldType = context.fieldMapper(fieldName);"
  },
  {
    "devdecision": "Combination",
    "id": 77448,
    "v2": "private String minimumShouldMatch;  private Boolean disableCoord;  private String queryName;",
    "resolution": "private String minimumShouldMatch;  private Boolean disableCoord;",
    "conflict": ""
  },
  {
    "devdecision": "Version 1",
    "id": 77451,
    "v2": "// search service -- testing only! String impl = settings.get(SEARCH_SERVICE_IMPL); if (impl == null) {",
    "resolution": "if (searchServiceImpl == SearchService.class) {",
    "conflict": "if (searchServiceImpl == SearchService.class) {"
  },
  {
    "devdecision": "Combination",
    "id": 77470,
    "v2": "import org.elasticsearch.test.ESTestCase;",
    "resolution": "import org.elasticsearch.index.query.MatchAllQueryBuilder; import org.elasticsearch.index.query.QueryBuilder; import org.elasticsearch.index.query.TermQueryBuilder;",
    "conflict": "import org.elasticsearch.index.query.MatchAllQueryBuilder; import org.elasticsearch.index.query.QueryBuilder; import org.elasticsearch.index.query.TermQueryBuilder; import org.elasticsearch.test.ElasticsearchTestCase;"
  },
  {
    "devdecision": "Combination",
    "id": 77471,
    "v2": "import org.elasticsearch.index.query.BoostableQueryBuilder; import org.elasticsearch.index.query.IdsQueryBuilder; import org.elasticsearch.index.query.MatchQueryBuilder; import org.elasticsearch.index.query.MatchQueryBuilder.Operator;",
    "resolution": "import org.elasticsearch.index.query.*; import org.elasticsearch.index.query.IdsQueryBuilder; import org.elasticsearch.index.query.MatchQueryBuilder;",
    "conflict": "import org.elasticsearch.index.query.*;"
  },
  {
    "devdecision": "Combination",
    "id": 77475,
    "v2": "public AssertingLocalTransport(Settings settings, ThreadPool threadPool, Version version) { super(settings, threadPool, version); final long seed = settings.getAsLong(ESIntegTestCase.SETTING_INDEX_SEED, 0l);",
    "resolution": "public AssertingLocalTransport(Settings settings, ThreadPool threadPool, Version version, NamedWriteableRegistry namedWriteableRegistry) { super(settings, threadPool, version, namedWriteableRegistry); final long seed = settings.getAsLong(ESIntegTestCase.SETTING_INDEX_SEED, 0l);",
    "conflict": "public AssertingLocalTransport(Settings settings, ThreadPool threadPool, Version version, NamedWriteableRegistry namedWriteableRegistry) { super(settings, threadPool, version, namedWriteableRegistry); final long seed = settings.getAsLong(ElasticsearchIntegrationTest.SETTING_INDEX_SEED, 0l);"
  },
  {
    "devdecision": "Combination",
    "id": 77477,
    "v2": "Path binDir = env.homeFile().resolve(\"bin\");",
    "resolution": "Environment env = initialSettings.v2(); Path binDir = env.binFile(); Path pluginBinDir = binDir.resolve(pluginName);",
    "conflict": "Path binDir = env.binFile(); if (!Files.exists(binDir)) { Files.createDirectories(binDir); }"
  },
  {
    "devdecision": "Version 2",
    "id": 77509,
    "v2": "if (boost != -1) { builder.field(\"boost\", boost); }",
    "resolution": "if (boost != -1) { builder.field(\"boost\", boost); }",
    "conflict": ""
  },
  {
    "devdecision": "Combination",
    "id": 77522,
    "v2": "assertAcked( client().admin().cluster().prepareUpdateSettings() .setTransientSettings(ImmutableSettings.builder()",
    "resolution": "assertAcked( client().admin().cluster().prepareUpdateSettings() .setTransientSettings(Settings.builder()",
    "conflict": "client().admin().cluster().prepareUpdateSettings() .setTransientSettings(Settings.builder()"
  },
  {
    "devdecision": "Combination",
    "id": 77529,
    "v2": "Clock clock, LicenseService licenseService, WatchStore watchStore, TriggerService triggerService, Watch.Parser watchParser) { super(settings, ExecuteWatchAction.NAME, transportService, clusterService, threadPool, actionFilters, licenseService);",
    "resolution": "Clock clock, LicenseService licenseService, WatchStore watchStore, TriggerService triggerService, Watch.Parser watchParser) { super(settings, ExecuteWatchAction.NAME, transportService, clusterService, threadPool, actionFilters, licenseService, ExecuteWatchRequest.class);",
    "conflict": "Clock clock, LicenseService licenseService, WatchStore watchStore, TriggerService triggerService) { super(settings, ExecuteWatchAction.NAME, transportService, clusterService, threadPool, actionFilters, licenseService, ExecuteWatchRequest.class);"
  },
  {
    "devdecision": "Combination",
    "id": 77539,
    "v2": "import com.carrotsearch.randomizedtesting.annotations.Seed; import org.elasticsearch.common.collect.ImmutableMap; import org.elasticsearch.common.netty.handler.codec.http.HttpHeaders; import org.elasticsearch.common.unit.TimeValue;",
    "resolution": "import com.google.common.collect.ImmutableMap; import org.elasticsearch.common.unit.TimeValue;",
    "conflict": "import com.google.common.collect.ImmutableMap;"
  },
  {
    "devdecision": "Version 1",
    "id": 77551,
    "v2": "import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.List;",
    "resolution": "import java.util.*;",
    "conflict": "import java.util.*;"
  },
  {
    "devdecision": "Combination",
    "id": 77556,
    "v2": "Settings v1 = replacePromptPlaceholders(settingsBuilder.build(), terminal);",
    "resolution": "String v = settingsBuilder.get(Settings.SETTINGS_REQUIRE_UNITS); if (v != null) { Settings.setSettingsRequireUnits(Booleans.parseBoolean(v, true)); }",
    "conflict": "String v = settingsBuilder.get(Settings.SETTINGS_REQUIRE_UNITS); if (v != null) { Settings.setSettingsRequireUnits(Booleans.parseBoolean(v, true)); } Settings v1 = settingsBuilder.build();"
  },
  {
    "devdecision": "Version 1",
    "id": 77563,
    "v2": "protected ParentFieldMapper(String name, String indexName, String type, @Nullable Settings fieldDataSettings, Settings indexSettings) { super(new Names(name, indexName, indexName, name), Defaults.BOOST, new FieldType(Defaults.FIELD_TYPE), Version.indexCreated(indexSettings).onOrAfter(Version.V_2_0_0), Lucene.KEYWORD_ANALYZER, Lucene.KEYWORD_ANALYZER, null, null, fieldDataSettings, indexSettings);",
    "resolution": "protected ParentFieldMapper(MappedFieldType fieldType, String type, @Nullable Settings fieldDataSettings, Settings indexSettings) { super(fieldType, false, fieldDataSettings, indexSettings);",
    "conflict": "protected ParentFieldMapper(MappedFieldType fieldType, String type, @Nullable Settings fieldDataSettings, Settings indexSettings) { super(fieldType, false, fieldDataSettings, indexSettings);"
  },
  {
    "devdecision": "Manual",
    "id": 77564,
    "v2": "fields.add(new Field(names.indexName(), Uid.createUid(context.stringBuilder(), type, parentId), fieldType)); if (hasDocValues()) { fields.add(createJoinField(type, parentId)); }",
    "resolution": "fields.add(new Field(fieldType.names().indexName(), Uid.createUid(context.stringBuilder(), type, parentId), fieldType)); if (fieldType.hasDocValues()) { fields.add(createJoinField(type, parentId)); }",
    "conflict": "fields.add(new Field(fieldType.names().indexName(), Uid.createUid(context.stringBuilder(), type, parentId), fieldType));"
  },
  {
    "devdecision": "Manual",
    "id": 77565,
    "v2": "fields.add(new Field(names.indexName(), Uid.createUid(context.stringBuilder(), type, parentId), fieldType)); if (hasDocValues()) { fields.add(createJoinField(type, parentId)); }",
    "resolution": "fields.add(new Field(fieldType.names().indexName(), Uid.createUid(context.stringBuilder(), type, parentId), fieldType)); if (fieldType.hasDocValues()) { fields.add(createJoinField(type, parentId)); }",
    "conflict": "fields.add(new Field(fieldType.names().indexName(), Uid.createUid(context.stringBuilder(), type, parentId), fieldType));"
  },
  {
    "devdecision": "Concatenation",
    "id": 77575,
    "v2": "/** Template to fill. */ private Template template;",
    "resolution": "/** Template to fill. */ private Template template;/** Name to reference this type of query. */ public static final String NAME = \"template\";",
    "conflict": "/** Name to reference this type of query. */ public static final String NAME = \"template\";"
  },
  {
    "devdecision": "Version 2",
    "id": 77578,
    "v2": "import java.util.concurrent.*;",
    "resolution": "import java.util.concurrent.*;",
    "conflict": "import java.util.concurrent.Callable; import java.util.concurrent.CopyOnWriteArrayList; import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutionException; import java.util.concurrent.TimeUnit;"
  },
  {
    "devdecision": "Manual",
    "id": 77580,
    "v2": "assertThat(indexShard.getOperationsCount(), equalTo(0));",
    "resolution": "assertThat(\"index shard counter on shard \" + indexShard.shardId() + \" on node \" + nodeAndClient.name + \" not 0\", indexShard.getOperationsCount(), equalTo(0));",
    "conflict": "assertThat(\"index shard counter on shard \" + indexShard.shardId() + \" on node \" + nodeAndClient.name + \" not 0 or 1 \", indexShard.getOperationsCount(), anyOf(equalTo(1), equalTo(0))); if (indexShard.getOperationsCount() == 0) { assertThat(indexShard.state(), equalTo(IndexShardState.CLOSED)); }"
  },
  {
    "devdecision": "Version 2",
    "id": 77599,
    "v2": "/** Extended SearcherFactory that warms the segments if needed when acquiring a new searcher */ final static class SearchFactory extends EngineSearcherFactory {",
    "resolution": "/** Extended SearcherFactory that warms the segments if needed when acquiring a new searcher */ final static class SearchFactory extends EngineSearcherFactory {",
    "conflict": "/** * Extended SearcherFactory that warms the segments if needed when acquiring a new searcher */ class SearchFactory extends EngineSearcherFactory {"
  },
  {
    "devdecision": "Combination",
    "id": 77609,
    "v2": "import org.elasticsearch.action.support.ToXContentToBytes; import org.elasticsearch.common.xcontent.XContentBuilder;",
    "resolution": "import org.apache.lucene.search.Query; import org.elasticsearch.action.support.ToXContentToBytes; import org.elasticsearch.common.xcontent.XContentBuilder; import org.elasticsearch.common.xcontent.XContentType;",
    "conflict": "import org.apache.lucene.search.Query; import org.elasticsearch.common.bytes.BytesReference; import org.elasticsearch.common.xcontent.ToXContent;"
  },
  {
    "devdecision": "Version 2",
    "id": 77617,
    "v2": "public ConstantScoreQueryBuilder(QueryBuilder filterBuilder) { this.filterBuilder = Objects.requireNonNull(filterBuilder);",
    "resolution": "public ConstantScoreQueryBuilder(QueryBuilder filterBuilder) { this.filterBuilder = Objects.requireNonNull(filterBuilder);",
    "conflict": "public ConstantScoreQueryBuilder(QueryBuilder queryBuilder) { this.filterBuilder = null; this.queryBuilder = queryBuilder;"
  },
  {
    "devdecision": "Version 1",
    "id": 77619,
    "v2": "",
    "resolution": "@Override protected String parserName() { return GeoShapeQueryParser.NAME; }",
    "conflict": "@Override protected String parserName() { return GeoShapeQueryParser.NAME; }"
  },
  {
    "devdecision": "Version 2",
    "id": 77621,
    "v2": "",
    "resolution": "",
    "conflict": "parser.nextToken(); } else { value = parser.objectText(); // move to the next token parser.nextToken();"
  },
  {
    "devdecision": "Version 2",
    "id": 77635,
    "v2": "/** * Return whether the setting is deprecated. */ public boolean isDeprecatedSetting(String setting) { return CACHE.match(setting) || CACHE_KEY.match(setting); }",
    "resolution": "/** * Return whether the setting is deprecated. */ public boolean isDeprecatedSetting(String setting) { return CACHE.match(setting) || CACHE_KEY.match(setting); }",
    "conflict": ""
  },
  {
    "devdecision": "Version 1",
    "id": 77637,
    "v2": "public IndexShard(ShardId shardId, IndexSettingsService indexSettingsService, IndicesLifecycle indicesLifecycle, Store store, MergeSchedulerProvider mergeScheduler, Translog translog, ThreadPool threadPool, MapperService mapperService, IndexQueryParserService queryParserService, IndexCache indexCache, IndexAliasesService indexAliasesService, ShardIndexingService indexingService, ShardGetService getService, ShardSearchService searchService, ShardIndexWarmerService shardWarmerService,",
    "resolution": "public IndexShard(ShardId shardId, IndexSettingsService indexSettingsService, IndicesLifecycle indicesLifecycle, Store store, MergeSchedulerProvider mergeScheduler, ThreadPool threadPool, MapperService mapperService, IndexQueryParserService queryParserService, IndexCache indexCache, IndexAliasesService indexAliasesService, ShardIndexingService indexingService, ShardGetService getService, ShardSearchService searchService, ShardIndexWarmerService shardWarmerService,",
    "conflict": "public IndexShard(ShardId shardId, IndexSettingsService indexSettingsService, IndicesLifecycle indicesLifecycle, Store store, MergeSchedulerProvider mergeScheduler, ThreadPool threadPool, MapperService mapperService, IndexQueryParserService queryParserService, IndexCache indexCache, IndexAliasesService indexAliasesService, ShardIndexingService indexingService, ShardGetService getService, ShardSearchService searchService, ShardIndexWarmerService shardWarmerService,"
  },
  {
    "devdecision": "Version 1",
    "id": 77642,
    "v2": "public void flush(FlushRequest request) { // we allows flush while recovering, since we allow for operations to happen // while recovering, and we want to keep the translog at bay (up to deletes, which // we don't gc).",
    "resolution": "public Engine.SyncedFlushResult syncFlushIfNoPendingChanges(String syncId, byte[] expectedCommitId) {",
    "conflict": "public Engine.SyncedFlushResult syncFlushIfNoPendingChanges(String syncId, byte[] expectedCommitId) {"
  },
  {
    "devdecision": "Manual",
    "id": 77644,
    "v2": "public EngineConfig(ShardId shardId, ThreadPool threadPool, ShardIndexingService indexingService, IndexSettingsService indexSettingsService, IndicesWarmer warmer, Store store, SnapshotDeletionPolicy deletionPolicy, Translog translog, MergePolicyProvider mergePolicyProvider, MergeSchedulerProvider mergeScheduler, Analyzer analyzer, Similarity similarity, CodecService codecService, Engine.FailedEngineListener failedEngineListener, TranslogRecoveryPerformer translogRecoveryPerformer, QueryCache filterCache, QueryCachingPolicy filterCachingPolicy) {",
    "resolution": "public EngineConfig(ShardId shardId, ThreadPool threadPool, ShardIndexingService indexingService, IndexSettingsService indexSettingsService, IndicesWarmer warmer, Store store, SnapshotDeletionPolicy deletionPolicy, MergePolicyProvider mergePolicyProvider, MergeSchedulerProvider mergeScheduler, Analyzer analyzer, Similarity similarity, CodecService codecService, Engine.FailedEngineListener failedEngineListener, TranslogRecoveryPerformer translogRecoveryPerformer, QueryCache filterCache, QueryCachingPolicy filterCachingPolicy) {",
    "conflict": "public EngineConfig(ShardId shardId, ThreadPool threadPool, ShardIndexingService indexingService, IndexSettingsService indexSettingsService, IndicesWarmer warmer, Store store, SnapshotDeletionPolicy deletionPolicy, MergePolicyProvider mergePolicyProvider, MergeSchedulerProvider mergeScheduler, Analyzer analyzer, Similarity similarity, CodecService codecService, Engine.FailedEngineListener failedEngineListener, TranslogRecoveryPerformer translogRecoveryPerformer) {"
  },
  {
    "devdecision": "Manual",
    "id": 77654,
    "v2": "if (factory != null) { throw new SearchParseException(context, \"Found two aggregation type definitions in [\" + aggregationName + \"]: [\" + factory.type + \"] and [\" + fieldName + \"]\", parser.getTokenLocation());",
    "resolution": "if (aggFactory != null) { throw new SearchParseException(context, \"Found two aggregation type definitions in [\" + aggregationName + \"]: [\" + aggFactory.type + \"] and [\" + fieldName + \"]\", parser.getTokenLocation());",
    "conflict": "if (aggFactory != null) { throw new SearchParseException(context, \"Found two aggregation type definitions in [\" + aggregationName + \"]: [\" + aggFactory.type + \"] and [\" + fieldName + \"]\");"
  },
  {
    "devdecision": "Version 1",
    "id": 77668,
    "v2": "",
    "resolution": "@Override protected String parserName() { return FunctionScoreQueryParser.NAME; }",
    "conflict": "@Override protected String parserName() { return FunctionScoreQueryParser.NAME; }"
  },
  {
    "devdecision": "Combination",
    "id": 77689,
    "v2": "IncludeExclude.StringFilter includeExclude, AggregationContext aggregationContext, Aggregator parent, SignificantTermsAggregatorFactory termsAggFactory, Map<String, Object> metaData) throws IOException {",
    "resolution": "IncludeExclude.StringFilter includeExclude, AggregationContext aggregationContext, Aggregator parent, SignificantTermsAggregatorFactory termsAggFactory, List<Reducer> reducers, Map<String, Object> metaData) throws IOException {",
    "conflict": "IncludeExclude includeExclude, AggregationContext aggregationContext, Aggregator parent, SignificantTermsAggregatorFactory termsAggFactory, List<Reducer> reducers, Map<String, Object> metaData) throws IOException {"
  },
  {
    "devdecision": "Manual",
    "id": 77694,
    "v2": "IncludeExclude.OrdinalsFilter includeExclude, AggregationContext aggregationContext, Aggregator parent, SubAggCollectionMode collectionMode, boolean showTermDocCountError, Map<String, Object> metaData) throws IOException { super(name, factories, aggregationContext, parent, order, bucketCountThresholds, collectionMode, showTermDocCountError, metaData);",
    "resolution": "IncludeExclude.OrdinalsFilter includeExclude, AggregationContext aggregationContext, Aggregator parent, SubAggCollectionMode collectionMode, boolean showTermDocCountError, List<Reducer> reducers, Map<String, Object> metaData) throws IOException { super(name, factories, aggregationContext, parent, order, bucketCountThresholds, collectionMode, showTermDocCountError, reducers, metaData);",
    "conflict": "IncludeExclude includeExclude, AggregationContext aggregationContext, Aggregator parent, SubAggCollectionMode collectionMode, boolean showTermDocCountError, List<Reducer> reducers, Map<String, Object> metaData) throws IOException { super(name, factories, aggregationContext, parent, order, bucketCountThresholds, collectionMode, showTermDocCountError, reducers, metaData);"
  },
  {
    "devdecision": "Combination",
    "id": 77695,
    "v2": "Terms.Order order, BucketCountThresholds bucketCountThresholds, IncludeExclude.OrdinalsFilter includeExclude, AggregationContext aggregationContext, Aggregator parent, SubAggCollectionMode collectionMode, boolean showTermDocCountError, Map<String, Object> metaData) throws IOException { super(name, factories, valuesSource, order, bucketCountThresholds, includeExclude, aggregationContext, parent, collectionMode, showTermDocCountError, metaData);",
    "resolution": "Terms.Order order, BucketCountThresholds bucketCountThresholds, IncludeExclude.OrdinalsFilter includeExclude, AggregationContext aggregationContext, Aggregator parent, SubAggCollectionMode collectionMode, boolean showTermDocCountError, List<Reducer> reducers, Map<String, Object> metaData) throws IOException { super(name, factories, valuesSource, order, bucketCountThresholds, includeExclude, aggregationContext, parent, collectionMode, showTermDocCountError, reducers, metaData);",
    "conflict": "Terms.Order order, BucketCountThresholds bucketCountThresholds, IncludeExclude includeExclude, AggregationContext aggregationContext, Aggregator parent, SubAggCollectionMode collectionMode, boolean showTermDocCountError, List<Reducer> reducers, Map<String, Object> metaData) throws IOException { super(name, factories, valuesSource, order, bucketCountThresholds, includeExclude, aggregationContext, parent, collectionMode, showTermDocCountError, reducers, metaData);"
  },
  {
    "devdecision": "Manual",
    "id": 77699,
    "v2": "AggregationContext aggregationContext, Aggregator parent, SubAggCollectionMode subAggCollectMode, boolean showTermDocCountError, Map<String, Object> metaData) throws IOException { final IncludeExclude.OrdinalsFilter filter = includeExclude == null ? null : includeExclude.convertToOrdinalsFilter(); return new GlobalOrdinalsStringTermsAggregator(name, factories, (ValuesSource.Bytes.WithOrdinals.FieldData) valuesSource, order, bucketCountThresholds, filter, aggregationContext, parent, subAggCollectMode, showTermDocCountError, metaData);",
    "resolution": "AggregationContext aggregationContext, Aggregator parent, SubAggCollectionMode subAggCollectMode, boolean showTermDocCountError, List<Reducer> reducers, Map<String, Object> metaData) throws IOException { final IncludeExclude.OrdinalsFilter filter = includeExclude == null ? null : includeExclude.convertToOrdinalsFilter(); return new GlobalOrdinalsStringTermsAggregator(name, factories, (ValuesSource.Bytes.WithOrdinals.FieldData) valuesSource, order, bucketCountThresholds, filter, aggregationContext, parent, subAggCollectMode, showTermDocCountError, reducers, metaData);",
    "conflict": "AggregationContext aggregationContext, Aggregator parent, SubAggCollectionMode subAggCollectMode, boolean showTermDocCountError, List<Reducer> reducers, Map<String, Object> metaData) throws IOException { return new GlobalOrdinalsStringTermsAggregator(name, factories, (ValuesSource.Bytes.WithOrdinals.FieldData) valuesSource, order, bucketCountThresholds, includeExclude, aggregationContext, parent, subAggCollectMode, showTermDocCountError, reducers, metaData);"
  },
  {
    "devdecision": "Manual",
    "id": 77700,
    "v2": "AggregationContext aggregationContext, Aggregator parent, SubAggCollectionMode subAggCollectMode, boolean showTermDocCountError, Map<String, Object> metaData) throws IOException { final IncludeExclude.OrdinalsFilter filter = includeExclude == null ? null : includeExclude.convertToOrdinalsFilter(); return new GlobalOrdinalsStringTermsAggregator.WithHash(name, factories, (ValuesSource.Bytes.WithOrdinals.FieldData) valuesSource, order, bucketCountThresholds, filter, aggregationContext, parent, subAggCollectMode, showTermDocCountError, metaData);",
    "resolution": "AggregationContext aggregationContext, Aggregator parent, SubAggCollectionMode subAggCollectMode, boolean showTermDocCountError, List<Reducer> reducers, Map<String, Object> metaData) throws IOException { final IncludeExclude.OrdinalsFilter filter = includeExclude == null ? null : includeExclude.convertToOrdinalsFilter(); return new GlobalOrdinalsStringTermsAggregator.WithHash(name, factories, (ValuesSource.Bytes.WithOrdinals.FieldData) valuesSource, order, bucketCountThresholds, filter, aggregationContext, parent, subAggCollectMode, showTermDocCountError, reducers, metaData);",
    "conflict": "AggregationContext aggregationContext, Aggregator parent, SubAggCollectionMode subAggCollectMode, boolean showTermDocCountError, List<Reducer> reducers, Map<String, Object> metaData) throws IOException { return new GlobalOrdinalsStringTermsAggregator.WithHash(name, factories, (ValuesSource.Bytes.WithOrdinals.FieldData) valuesSource, order, bucketCountThresholds, includeExclude, aggregationContext, parent, subAggCollectMode, showTermDocCountError, reducers, metaData);"
  },
  {
    "devdecision": "Manual",
    "id": 77711,
    "v2": "final InternalStats stats = super.reduce(aggregations, reduceContext); return new InternalExtendedStats(name, stats.getCount(), stats.getSum(), stats.getMin(), stats.getMax(), sumOfSqrs, sigma, valueFormatter, getMetaData());",
    "resolution": "final InternalStats stats = super.doReduce(aggregations, reduceContext); return new InternalExtendedStats(name, stats.getCount(), stats.getSum(), stats.getMin(), stats.getMax(), sumOfSqrs, sigma, valueFormatter, reducers(), getMetaData());",
    "conflict": "final InternalStats stats = super.doReduce(reduceContext); return new InternalExtendedStats(name, stats.getCount(), stats.getSum(), stats.getMin(), stats.getMax(), sumOfSqrs, sigma, valueFormatter, reducers(), getMetaData());"
  },
  {
    "devdecision": "Combination",
    "id": 77716,
    "v2": "String reduceScript, Map<String, Object> params, Map<String, Object> reduceParams, AggregationContext context, Aggregator parent, Map<String, Object> metaData) throws IOException { super(name, context, parent, metaData);",
    "resolution": "String reduceScript, Map<String, Object> params, Map<String, Object> reduceParams, AggregationContext context, Aggregator parent, List<Reducer> reducers, Map<String, Object> metaData) throws IOException { super(name, context, parent, reducers, metaData);",
    "conflict": "String reduceScript, Map<String, Object> params, Map<String, Object> reduceParams, AggregationContext context, Aggregator parent, List<Reducer> reducers, Map<String, Object> metaData) throws IOException { super(name, context, parent, reducers, metaData); this.scriptService = context.searchContext().scriptService();"
  },
  {
    "devdecision": "Combination",
    "id": 77719,
    "v2": "@Override protected AbstractInternalPercentiles createReduced(String name, double[] keys, TDigestState merged, boolean keyed, Map<String, Object> metaData) { return new InternalPercentileRanks(name, keys, merged, keyed, valueFormatter, metaData);",
    "resolution": "@Override protected AbstractInternalPercentiles createReduced(String name, double[] keys, TDigestState merged, boolean keyed, List<Reducer> reducers, Map<String, Object> metaData) { return new InternalPercentileRanks(name, keys, merged, keyed, valueFormatter, reducers, metaData);",
    "conflict": "protected AbstractInternalPercentiles createReduced(String name, double[] keys, TDigestState merged, boolean keyed, List<Reducer> reducers, Map<String, Object> metaData) { return new InternalPercentileRanks(name, keys, merged, keyed, valueFormatter, reducers, metaData);"
  },
  {
    "devdecision": "Combination",
    "id": 77720,
    "v2": "@Override protected AbstractInternalPercentiles createReduced(String name, double[] keys, TDigestState merged, boolean keyed, Map<String, Object> metaData) { return new InternalPercentiles(name, keys, merged, keyed, valueFormatter, metaData);",
    "resolution": "@Override protected AbstractInternalPercentiles createReduced(String name, double[] keys, TDigestState merged, boolean keyed, List<Reducer> reducers, Map<String, Object> metaData) { return new InternalPercentiles(name, keys, merged, keyed, valueFormatter, reducers, metaData);",
    "conflict": "protected AbstractInternalPercentiles createReduced(String name, double[] keys, TDigestState merged, boolean keyed, List<Reducer> reducers, Map<String, Object> metaData) { return new InternalPercentiles(name, keys, merged, keyed, valueFormatter, reducers, metaData);"
  },
  {
    "devdecision": "Version 2",
    "id": 77721,
    "v2": "",
    "resolution": "",
    "conflict": "public InternalTopHits(String name, InternalSearchHits searchHits, List<Reducer> reducers, Map<String, Object> metaData) { super(name, reducers, metaData); this.searchHits = searchHits; this.topDocs = Lucene.EMPTY_TOP_DOCS; }"
  },
  {
    "devdecision": "Version 1",
    "id": 77738,
    "v2": "",
    "resolution": "import org.elasticsearch.alerts.transport.actions.delete.DeleteAlertRequest; import org.elasticsearch.alerts.transport.actions.delete.DeleteAlertResponse; import org.elasticsearch.alerts.transport.actions.get.GetAlertRequest; import org.elasticsearch.alerts.transport.actions.get.GetAlertResponse; import org.elasticsearch.alerts.transport.actions.update.UpdateAlertRequest; import org.elasticsearch.alerts.transport.actions.update.UpdateAlertResponse;",
    "conflict": "import org.elasticsearch.alerts.transport.actions.delete.DeleteAlertRequest; import org.elasticsearch.alerts.transport.actions.delete.DeleteAlertResponse; import org.elasticsearch.alerts.transport.actions.get.GetAlertRequest; import org.elasticsearch.alerts.transport.actions.get.GetAlertResponse; import org.elasticsearch.alerts.transport.actions.update.UpdateAlertRequest; import org.elasticsearch.alerts.transport.actions.update.UpdateAlertResponse;"
  },
  {
    "devdecision": "Manual",
    "id": 77745,
    "v2": "bulkRequestBuilder.setTimeout(timeout); checkBulkAction(false, timeout, bulkRequestBuilder);",
    "resolution": "checkBulkAction(false, bulkRequestBuilder);",
    "conflict": "// today, we clear the metadata on when there is no master, so it will go through the auto create logic and // add it... (if autoCreate is set to true) checkBulkAction(autoCreateIndex, bulkRequestBuilder);"
  }
]
}